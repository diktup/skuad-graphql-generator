type FilterNameFieldType {
  id: ID!
  name: String
}

type FilterLabelFieldType {
  id: ID!
  label: String
}

type PictureType {
  baseUrl: String
  path: String
  width: Int
  height: Int
  x: Int
  y: Int
  alt: String
}

type NestedPicturesType {
  cover: PictureType
  profile: PictureType
}

type CountryType {
  id: ID!
  name: String!
  code: String
  dialCode: String
  flagSquare: PictureType
  flagWide: PictureType
  iconFlag: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

# A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format.
scalar DateTime

type CountryPaginatedType {
  count: Int
  isLast: Boolean
  objects: [CountryType!]!
}

type DeleteResponseDtoType {
  message: String!
  success: Boolean!
}

type StateType {
  id: ID!
  name: String!
  created: DateTime!
  surface: String!
  code: String
  dialCode: String
  flagSquare: PictureType
  flagWide: PictureType
  country: CountryType
  createdAt: DateTime!
  updatedAt: DateTime!
}

type StatePaginatedType {
  count: Int
  isLast: Boolean
  objects: [StateType!]!
}

type LanguageType {
  id: ID!
  name: String!
  code: String
  flagSquare: PictureType
  flagWide: PictureType
  iconFlag: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type LanguagePaginatedType {
  count: Int
  isLast: Boolean
  objects: [LanguageType!]!
}

type SocialImagesImagesSetType {
  size48: PictureType
  size96: PictureType
  size144: PictureType
  size240: PictureType
  size480: PictureType
}

type SocialImagesImagesType {
  svg: SocialImagesImagesSetType
  png: SocialImagesImagesSetType
}

type SocialImagesType {
  style: SocialImageStyleEnum!
  images: [SocialImagesImagesType!]
}

enum SocialImageStyleEnum {
  BUBBLE
  COLOR
  STICKER
  COLOR_HAND_DROWN
}

type SocialType {
  id: ID!
  name: String!
  code: String
  fontIcon: String
  images: [SocialImagesType!]
  createdAt: DateTime!
  updatedAt: DateTime!
}

type SocialPaginatedType {
  count: Int
  isLast: Boolean
  objects: [SocialType!]!
}

type PaymentImagesPngType {
  alt: PictureType
  alt2x: PictureType
  alt_128: PictureType
  alt_256: PictureType
  alt_512: PictureType
  card_flat: PictureType
  card_flat2x: PictureType
  card_flat_128: PictureType
  card_flat_256: PictureType
  card_flat_512: PictureType
  dark: PictureType
  dark2x: PictureType
  dark_128: PictureType
  dark_256: PictureType
  dark_512: PictureType
  flat: PictureType
  flat2x: PictureType
  flat_128: PictureType
  flat_256: PictureType
  flat_512: PictureType
  light: PictureType
  light2x: PictureType
  light_128: PictureType
  light_256: PictureType
  light_512: PictureType
  default: PictureType
  default2x: PictureType
  default_128: PictureType
  default_256: PictureType
  default_512: PictureType
}

type PaymentImagesSvgType {
  alt: PictureType
  card_flat: PictureType
  dark: PictureType
  flat: PictureType
  light: PictureType
  default: PictureType
}

type PaymentImagesType {
  svg: PaymentImagesSvgType
  png: PaymentImagesPngType
}

type PaymentType {
  id: ID!
  name: String!
  code: String
  paymentType: PaymentTypeEnum
  materialIcon: String
  images: PaymentImagesType
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum PaymentTypeEnum {
  CREDIT_CARD
  PAYMENT
  METHODS
}

type PaymentPaginatedType {
  count: Int
  isLast: Boolean
  objects: [PaymentType!]!
}

type GlobalCategoryType {
  id: ID!
  identifier: Int!
  name: String!
  provider: GlobalCategoryProviderEnum
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum GlobalCategoryProviderEnum {
  GOOGLE
  FACEBOOK
}

type BrowserLogoPngType {
  default: PictureType
  size16: PictureType
  size24: PictureType
  size32: PictureType
  size48: PictureType
  size64: PictureType
  size128: PictureType
  size256: PictureType
  size512: PictureType
}

type BrowserLogoType {
  svg: PictureType
  png: BrowserLogoPngType
  icon: String
}

type BrowserType {
  id: ID!
  name: String
  tags: [String!]
  code: String!
  logo: BrowserLogoType
  createdAt: DateTime!
  updatedAt: DateTime!
}

type BrowserPaginatedType {
  count: Int
  isLast: Boolean
  objects: [BrowserType!]!
}

type DeviceBrandLogoPngType {
  default: PictureType
  size16: PictureType
  size24: PictureType
  size32: PictureType
  size48: PictureType
  size64: PictureType
  size128: PictureType
  size256: PictureType
  size512: PictureType
}

type DeviceBrandLogoType {
  svg: PictureType
  png: DeviceBrandLogoPngType
  icon: String
}

type TechDeviceBrandType {
  id: ID!
  name: String!
  code: String
  tags: [String!]
  logo: DeviceBrandLogoType
  createdAt: DateTime!
  updatedAt: DateTime!
}

type TechDeviceBrandPaginatedType {
  count: Int
  isLast: Boolean
  objects: [TechDeviceBrandType!]!
}

type TechDeviceSpecsType {
  technology: String
  band2g: String
  gprs: String
  edge: String
  announced: String
  status: String
  dimensions: String
  weight: String
  sim: String
  type: String
  size: String
  resolution: String
  cardSlot: String
  phonebook: String
  callRecords: String
  loudspeaker: String
  alertTypes: String
  jack35mm: String
  wlan: String
  bluetooth: String
  gps: String
  radio: String
  usb: String
  sensors: String
  messaging: String
  browser: String
  clock: String
  alarm: String
  games: String
  languages: String
  java: String
  colors: String
}

type TechDeviceType {
  id: ID!
  name: String
  tags: [String!]
  code: String
  picture: PictureType
  releasedat: String
  body: String
  os: String
  storage: String
  displaySize: String
  displayResolution: String
  cameraPixels: String
  videoPixels: String
  ram: String
  chipset: String
  batterySize: String
  batteryType: String
  specifications: TechDeviceSpecsType
  brand: TechDeviceBrandType
  createdAt: DateTime!
  updatedAt: DateTime!
}

type TechDevicePaginatedType {
  count: Int
  isLast: Boolean
  objects: [TechDeviceType!]!
}

type TechDeviceTypeType {
  id: ID!
  name: String
  tags: [String!]
  nodeName: String
  code: String
  pictureSquare: PictureType
  pictureWide: PictureType
  icon: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type TechDeviceTypePaginatedType {
  count: Int
  isLast: Boolean
  objects: [TechDeviceTypeType!]!
}

type OSLogoPngType {
  default: PictureType
  size16: PictureType
  size24: PictureType
  size32: PictureType
  size48: PictureType
  size64: PictureType
  size128: PictureType
}

type OSLogoType {
  svg: PictureType
  png: OSLogoPngType
  icon: String
}

type OperatingSystemType {
  id: ID!
  name: String!
  code: String
  tags: [String!]
  slug: String
  logo: OSLogoType
  createdAt: DateTime!
  updatedAt: DateTime!
}

type OperatingSystemPaginatedType {
  count: Int
  isLast: Boolean
  objects: [OperatingSystemType!]!
}

type PluginPicturesType {
  square: PictureType
  wide: PictureType
}

type PluginType {
  id: ID!
  name: String!
  description: String
  code: String
  cost: String
  url: String
  info: String
  category: String
  pictures: PluginPicturesType
  icon: String
  recommended: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type LonLatType {
  type: String
  coordinates: [Float!]
}

type FullAddressOwnerPhoneType {
  number: String
  countryCode: String
}

type FullAddressOwnerType {
  name: String
  phone: FullAddressOwnerPhoneType
}

type FullAddressType {
  owner: FullAddressOwnerType
  address: String
  postCode: String
  city: String
  country: CountryType
  state: StateType
  addressLine: String
  location: LonLatType
}

type BankType {
  id: ID!
  name: String!
  code: String
  bic: String
  address: FullAddressType
  logo: BrowserLogoType
  createdAt: DateTime!
  updatedAt: DateTime!
}

type BankDetailsHolderType {
  name: String!
  type: BankDetailsHolderTypeEnum
  address: FullAddressType!
}

enum BankDetailsHolderTypeEnum {
  PRIVATE
  COMPANY
}

type BankDetailsType {
  id: ID!
  account: String!
  iban: String
  bank: BankType!
  holder: BankDetailsHolderType!
  externalId: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ContentTypeImageFormatType {
  png: PictureType
  svg: PictureType
}

type ContentTypeImageType {
  background: ContentTypeImageFormatType
  black: ContentTypeImageFormatType
  white: ContentTypeImageFormatType
  icon: String
}

type ContentTypeType {
  id: ID!
  name: String!
  type: String
  image: ContentTypeImageType
  createdAt: DateTime!
  updatedAt: DateTime!
}

type SocialValueType {
  name: SocialType
  value: String
}

type TagType {
  name: String
  content: String
}

type DateRangeType {
  min: DateTime
  max: DateTime
}

type PriceRangeType {
  min: String
  max: String
}

type GroupType {
  id: ID!
  name: String!
  description: String
  isVerified: Boolean
  picture: NestedPicturesType
  privacy: GroupPrivacyEnum!
  members: [UserType!]!
  moderators: [UserType!]!
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum GroupPrivacyEnum {
  PRIVATE
  PUBLIC
}

type GroupPaginateType {
  count: Int
  isLast: Boolean
  objects: [GroupType!]!
}

type MediaType {
  videos: [String!]
  pictures: [PictureType!]
  deg360: [PictureType!]
}

type IPhoneType {
  number: String
  countryCode: String
}

type PhoneType {
  number: String
  countryCode: String
  isValid: Boolean
  validationNumber: Int
}

type CompanyCustomerType {
  phase: CustomerPhaseEnum
  score: String
}

enum CustomerPhaseEnum {
  LEAD
  CUSTOMER
  TERMINATION
}

type CompanySupplierType {
  kind: SupplierTypeEnum
}

enum SupplierTypeEnum {
  WHOLESALER
  MANUFACTURER
  FRANCHISE
}

type CompanyContactDetailsType {
  website: String
  email: String
  phone: PhoneType
}

type CompanyLegalType {
  vat: String
  register: String
  licence: String
}

type CompanyType {
  id: ID!
  name: String
  description: String
  tags: [String!]
  media: MediaType
  address: FullAddressType
  legal: CompanyLegalType
  banks: [BankDetailsType!]
  contact: CompanyContactDetailsType
  customer: CompanyCustomerType
  supplier: CompanySupplierType
  logistic: Boolean
  target: TargetType
  externalId: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type WholesalerType {
  id: ID!
  name: String
  description: String
  address: FullAddressType
  picture: PictureType
  email: String
  website: String
  phone: IPhoneType
  contactEmails: [String!]
  fax: IPhoneType
  createdAt: DateTime!
  updatedAt: DateTime!
  company: CompanyType
}

type LoyaltyProgramType {
  id: ID!
  programName: String
  picture: PictureType
  company: CompanyType
  createdAt: DateTime!
  updatedAt: DateTime!
}

type POSLoyaltyType {
  loyaltyProgram: LoyaltyProgramType
  from: DateTime!
  to: DateTime!
}

type OpeningHoursDayType {
  day: Days
  from: String
  to: String
}

enum Days {
  MONDAY
  TUESDAY
  WEDNESDAY
  THURSDAY
  FRIDAY
  SATURDAY
  SUNDAY
}

type OpeningHoursType {
  status: OpeningStatus
  hours: [OpeningHoursDayType!]
}

enum OpeningStatus {
  ALWAYS_OPEN
  NOT_AVAILABLE
  SELECTED_HOURS
  PERMANENTLY_CLOSED
}

type SpecialOfferType {
  offerType: SpecialOffersType
  hours: [OpeningHoursDayType!]
}

enum SpecialOffersType {
  BAR
  LUNCH
  BRUNCH
  DINNER
  BREAKFAST
  HAPPY_HOUR
}

type POSCategoryType {
  id: ID!
  name: String
  mapPicture: String
  picture: PictureType
  createdAt: DateTime!
  updatedAt: DateTime!
}

type POSServicesType {
  id: ID
  index: Int
  name: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type PointOfSaleType {
  id: ID!
  name: String
  title: String
  subtitle: String
  description: String
  tags: [String!]
  brandColor: String
  reference: String
  published: Boolean
  picture: PictureType
  outsidePictures: [PictureType!]
  insidePictures: [PictureType!]
  openingHours: OpeningHoursType
  specialOffers: [SpecialOfferType!]
  email: [String!]
  contactEmails: [String!]
  currency: Currency
  languages: [LanguageType!]
  phone: [String!]
  website: String
  chatContact: [SocialValueType!]
  socialMedia: [SocialValueType!]
  averageCustomers: Float
  turnover: String
  locations: [FullAddressType!]
  isFollowed: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
  posCategory: [POSCategoryType!]
  company: CompanyType
  services: [POSServicesType!]
  paymentMethods: [PaymentType!]
  loyaltyPrograms: [POSLoyaltyType!]
}

enum Currency {
  EUR
  USD
  TND
}

type ManufacturerType {
  id: ID!
  name: String
  description: String
  picture: PictureType
  externalId: String
  address: FullAddressType
  email: String
  website: String
  contactEmails: [String!]
  createdAt: DateTime!
  updatedAt: DateTime!
  company: CompanyType
}

type StoryContentPositionType {
  left: Float
  right: Float
  top: Float
  bottom: Float
}

type StoryContentDimensionType {
  height: Float
  width: Float
  fontSize: Float
}

type StoryContentContentType {
  content: String
  position: StoryContentPositionType
  dimension: StoryContentDimensionType
  color: String
  contentType: StoriesContentTypeEnum
}

enum StoriesContentTypeEnum {
  GIF
  TEXT
  STICKER
  EMOJI
}

type StoryMediaType {
  picture: PictureType
  video: PictureType
}

type StoriesType {
  id: ID!
  media: StoryMediaType
  seenBy: [UserType!]
  seen: Boolean
  content: [StoryContentContentType!]
  user: UserType
  createdAt: DateTime!
  updatedAt: DateTime!
  pos: PointOfSaleType
  wholesaler: WholesalerType
  manufacturer: ManufacturerType

  # group
  group: GroupType
}

type StoriesViewsStatusType {
  id: ID!
  seen: Boolean!
  user: String
  pos: String
  group: String
  wholesaler: String
  manufacturer: String
}

type StoriesPaginatedType {
  count: Int
  isLast: Boolean
  objects: [StoriesType!]!
  isAllStoriesSeen: Boolean!
}

type TargetType {
  # PointOfSale
  pos: PointOfSaleType

  # wholesaler
  wholesaler: WholesalerType

  # manufacturer
  manufacturer: ManufacturerType
}

type TargetWithUserType {
  # PointOfSale
  pos: PointOfSaleType

  # wholesaler
  wholesaler: WholesalerType

  # manufacturer
  manufacturer: ManufacturerType

  # user
  user: UserType
}

type TargetFilterType {
  # PointOfSale
  pos: FilterNameFieldType

  # wholesaler
  wholesaler: FilterNameFieldType

  # manufacturer
  manufacturer: FilterNameFieldType
}

type TargetWithGroupType {
  # PointOfSale
  pos: PointOfSaleType

  # wholesaler
  wholesaler: WholesalerType

  # manufacturer
  manufacturer: ManufacturerType

  # user
  user: UserType

  # group
  group: GroupType
}

type TargetWithGroupAndStoriesType {
  # PointOfSale
  pos: PointOfSaleType

  # wholesaler
  wholesaler: WholesalerType

  # manufacturer
  manufacturer: ManufacturerType

  # user
  user: UserType

  # group
  group: GroupType

  # Stories list
  stories: [StoriesType!]

  # is all Stories are seen
  isAllStoriesSeen: Boolean!
}

type TargetsType {
  # list of pointOfSales
  pos: [PointOfSaleType!]

  # list of wholesalers
  wholesaler: [WholesalerType!]

  # list of manufacturers
  manufacturer: [ManufacturerType!]
}

type TargetPaginateType {
  count: Int
  isLast: Boolean
  objects: [TargetType!]!
}

type TargetWithGroupPaginateType {
  count: Int
  isLast: Boolean
  objects: [TargetWithGroupType!]!
}

type TargetWithGroupAndStoriesPaginateType {
  count: Int
  isLast: Boolean
  objects: [TargetWithGroupAndStoriesType!]!
}

type DiscountDtoType {
  discountType: DiscountType
  amount: String
}

enum DiscountType {
  AMOUNT
  PERCENTAGE
}

type BooleanCheckType {
  response: Boolean!
}

type MetaItemType {
  name: String
  content: String
  property: String
}

type LinkItemType {
  rel: String
  href: String
  type: String
  sizes: String
}

type InvoicePDFType {
  content: String
}

type StringListType {
  list: [String!]
}

type PriceCountType {
  price: String
  count: Float
}

type DifferenceInnerType {
  amount: String
  percentage: String
}

type DifferenceType {
  price: DifferenceInnerType
  count: DifferenceInnerType
}

type CurrentPreviousType {
  current: PriceCountType!
  previous: PriceCountType
  difference: DifferenceType
}

type InstallmentType {
  _id: ID!
  amount: String!
  paymentMethod: PaymentType!
  paymentStatus: PaymentStatusEnum!
  user: UserType
  paidAt: DateTime
  deadline: DateTime
}

enum PaymentStatusEnum {
  OPEN
  PAID
  CANCELED
  REFUNDED
  REFUND_REQUESTED
}

type ProductSpecsType {
  key: String
  value: String
}

type KeyValueListType {
  key: String
  value: String
}

type OoredooDataType {
  id: String
}

type FacebookDataType {
  id: String!
  token: String!
  email: String!
  name: String
  first_name: String
  last_name: String
}

type GoogleDataType {
  sub: String!
  given_name: String
  name: String
  family_name: String
  picture: String
  email: String!
  token: String!
  locale: String
  email_verified: Boolean
}

type AppleDataType {
  email: String
  status: String
  givenName: String
  familyName: String
  identityToken: String!
  userIdentifier: String
  authorizationCode: String
}

type SocialLoginDataType {
  facebook: FacebookDataType
  google: GoogleDataType
  apple: AppleDataType
  ooredoo: OoredooDataType
}

type UserWorkType {
  company: String
  position: String
  description: String
  city: StateType
  tags: [String!]
  from: DateTime
  to: DateTime
  current: Boolean
}

type UserEducationType {
  level: AcademicLevel
  name: String
  description: String
  tags: [String!]
  from: DateTime
  to: DateTime
  graduated: Boolean
}

enum AcademicLevel {
  PRIMARY
  HIGH_SCHOOL
  UNIVERSITY
}

type UserType {
  id: ID!
  email: String
  picture: PictureType
  pictures: [PictureType!]
  covers: [PictureType!]
  roles: [UserRole!]
  username: String
  firstName: String
  status: UserStatus
  title: String
  about: String
  lastName: String
  apps: [App!]
  maritalStatus: MaritalStatus
  gender: Gender
  languages: [LanguageType!]
  education: [UserEducationType!]
  work: [UserWorkType!]
  lived: [StateType!]
  hobbies: [String!]
  interests: [String!]
  isMailValid: Boolean
  plugged: Boolean
  hasAutoGeneratedEmail: Boolean
  dateOfBirth: DateTime
  phoneNumber: String
  phone: PhoneType
  chatContact: [SocialValueType!]
  socialMedia: [SocialValueType!]
  socialLoginData: SocialLoginDataType
  nationality: CountryType
  locale: String
  placeOfBirth: String
  residentialAddress: [FullAddressType!]
  shippingAddress: [FullAddressType!]
  billingAddress: [FullAddressType!]
  mobileTheme: MobileThemesEnum
  source: SourcesEnum
  newsletterSubs: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum UserRole {
  API
  ADMIN
  EDITOR
  MANAGER
  CONSUMER
  COMMUNITY
  FINANCIAL
  WAREHOUSE
  COMMERCIAL
  MERCHANDISER
  NOT_SPECIFIED
  GROUP_MODERATOR
  WHOLESALER_OWNER
  WHOLESALER_MANAGER
  MANUFACTURER_OWNER
  WHOLESALER_ASSISTANT
  MANUFACTURER_MANAGER
  MANUFACTURER_ASSISTANT
  SALES
  SYSTEM
  CATALOG
  CONTENT
  LOYALTY
  NETWORK
  CUSTOMERS
  INVENTORY
  ORGANIZATION
  MERCHANDISING
  DASHBOARDS_SALES
  DASHBOARDS_FINANCE
  DASHBOARDS_ANALYTICS
  DASHBOARDS_WAREHOUSE
  DASHBOARDS_MERCHANDISING
  POS_OWNER
  POS_WAITER
  POS_MANAGER
  DELIVERY_MAN
  POS_ASSISTANT
}

enum UserStatus {
  ONLINE
  AWAY
  BUSY
  OFFLINE
}

enum App {
  BOSK
  SKUAD
  FIGAMY
  COCKPIT
  DIKTUP
  MAGARI
  RECOLDA
  SIFCA
}

enum MaritalStatus {
  SINGLE
  MARRIED
  ENGAGED
  WIDOWED
  DIVORCED
  SEPERATED
  IN_RELATIONSHIP
  PREFER_NOT_TO_SAY
}

enum Gender {
  MALE
  FEMALE
  PREFER_NOT_TO_SAY
}

enum MobileThemesEnum {
  DARK
  LIGHT
  SYSTEM
}

enum SourcesEnum {
  FIGAMY
  OOREDOO
}

type UserExistType {
  exist: Boolean!
  user: UserType
}

type VapidKeyType {
  vapidKey: String!
}

type IsLoggedInType {
  expired: Boolean!
}

type UserPaginateType {
  count: Int
  isLast: Boolean
  objects: [UserType!]!
}

type MailResponseDto {
  accepted: [String!]!
  rejected: [String!]!
  envelopeTime: Float!
  messageTime: Float!
  messageSize: Float!
  response: String!
  messageId: String!
}

type EmailTemplateType {
  name: EmailTemplateTypeEnum!
  content: String!
}

enum EmailTemplateTypeEnum {
  STYLE
  WELCOME_USER
  VALIDATE_EMAIL
  FORGOT_PASSWORD
  CONFIRM_PASSWORD
  CONTACT_REQUEST
  DEMO_BOOKING
  EXPORT
  FORM_EXPORT
  INVOICE
  DOCUMENT
  MERGE_ACCOUNTS
  PARTNERSHIP_REFERRAL
  PARTNERSHIP_REQUEST
  POS_CONTACT_REQUEST
  TABLE_GUIDANCE
  SUBSCRIPTION
  PAYMENT_DECLINED
  PAYMENT_CONFIRMED
  PROMOTION
  NEWSLETTER
  BLOG
}

type AuthDashboardAgeType {
  ageRange: String!
  count: Int!
}

type AuthDashboardRoleType {
  role: UserRole!
  count: Int!
}

type AuthDashboardGenderType {
  gender: Gender!
  count: Int!
}

type AuthDashboardUsersByAppsType {
  app: App!
  count: Int!
}

type AuthDashboardMaritalStatusType {
  maritalStatus: MaritalStatus!
  count: Int!
}

type AuthDashboardUsersByRegionType {
  region: CountryEnum!
  count: Int!
}

enum CountryEnum {
  AFGHANISTAN
  ALBANIA
  ALGERIA
  ANDORRA
  ANGOLA
  ANTIGUA_AND_BARBUDA
  ARGENTINA
  ARMENIA
  AUSTRALIA
  AUSTRIA
  AZERBAIJAN
  BAHAMAS
  BAHRAIN
  BANGLADESH
  BARBADOS
  BELARUS
  BELGIUM
  BELIZE
  BENIN
  BHUTAN
  BOLIVIA
  BOSNIA_AND_HERZEGOVINA
  BOTSWANA
  BRAZIL
  BRUNEI
  BULGARIA
  BURKINA_FASO
  BURUNDI
  IVORY_COAST
  CABO_VERDE
  CAMBODIA
  CAMEROON
  CANADA
  CENTRALA_FRICAN_REPUBLIC
  CHAD
  CHILE
  CHINA
  COLOMBIA
  COMOROS
  CONGO_BRAZZAVILLE
  COSTA_RICA
  CROATIA
  CUBA
  CYPRUS
  CZECH_REPUBLIC
  DEMOCRATIC_REPUBLIC_OF_THE_CONGO
  DENMARK
  DJIBOUTI
  DOMINICA
  DOMINICAN_REPUBLIC
  ECUADOR
  EGYPT
  EL_SALVADOR
  EQUATORIAL_GUINEA
  ERITREA
  ESTONIA
  ESWATINI
  ETHIOPIA
  FIJI
  FINLAND
  FRANCE
  GABON
  GAMBIA
  GEORGIA
  GERMANY
  GHANA
  GREECE
  GRENADA
  GUATEMALA
  GUINEA
  GUINEA_BISSAU
  GUYANA
  HAITI
  HOLY_SEE
  HONDURAS
  HUNGARY
  ICELAND
  INDIA
  INDONESIA
  IRAN
  IRAQ
  IRELAND
  ISRAEL
  ITALY
  JAMAICA
  JAPAN
  JORDAN
  KAZAKHSTAN
  KENYA
  KIRIBATI
  KUWAIT
  KYRGYZSTAN
  LAOS
  LATVIA
  LEBANON
  LESOTHO
  LIBERIA
  LIBYA
  LIECHTENSTEIN
  LITHUANIA
  LUXEMBOURG
  MADAGASCAR
  MALAWI
  MALAYSIA
  MALDIVES
  MALI
  MALTA
  MARSHALL_ISLANDS
  MAURITANIA
  MAURITIUS
  MEXICO
  MICRONESIA
  MOLDOVA
  MONACO
  MONGOLIA
  MONTENEGRO
  MOROCCO
  MOZAMBIQUE
  MYANMAR
  NAMIBIA
  NAURU
  NEPAL
  NETHERLANDS
  NEW_ZEALAND
  NICARAGUA
  NIGER
  NIGERIA
  NORTH_KOREA
  NORTH_MACEDONIA
  NORWAY
  OMAN
  PAKISTAN
  PALAU
  PALESTINE_STATE
  PANAMA
  PAPUA_NEW_GUINEA
  PARAGUAY
  PERU
  PHILIPPINES
  POLAND
  PORTUGAL
  QATAR
  ROMANIA
  RUSSIA
  RWANDA
  SAINT_KITTS_AND_NEVIS
  SAINT_LUCIA
  SAINT_VINCENT_AND_THE_GRENADINES
  SAMOA
  SAN_MARINO
  SAO_TOME_AND_PRINCIPE
  SAUDI_ARABIA
  SENEGAL
  SERBIA
  SEYCHELLES
  SIERRA_LEONE
  SINGAPORE
  SLOVAKIA
  SLOVENIA
  SOLOMON_ISLANDS
  SOMALIA
  SOUTH_AFRICA
  SOUTH_KOREA
  SOUTH_SUDAN
  SPAIN
  SRI_LANKA
  SUDAN
  SURINAME
  SWEDEN
  SWITZERLAND
  SYRIA
  TAJIKISTAN
  TANZANIA
  THAILAND
  TIMOR_LESTE
  TOGO
  TONGA
  TRINIDAD_AND_TOBAGO
  TUNISIA
  TURKEY
  TURKMENISTAN
  TUVALU
  UGANDA
  UKRAINE
  UNITED_ARAB_EMIRATES
  UNITED_KINGDOM
  UNITED_STATES_OF_AMERICA
  URUGUAY
  UZBEKISTAN
  VANUATU
  VENEZUELA
  VIETNAM
  YEMEN
  ZAMBIA
  ZIMBABWE
  NOT_SPECIFIED
}

type AuthDashboardMailValidationType {
  isMailValid: Boolean!
  count: Int!
}

type AuthDashboardType {
  gender: [AuthDashboardGenderType!]!
  maritalStatus: [AuthDashboardMaritalStatusType!]!
  usersByRegion: [AuthDashboardUsersByRegionType!]!
  mailValidation: [AuthDashboardMailValidationType!]!
  roles: [AuthDashboardRoleType!]!
  usersByApp: [AuthDashboardUsersByAppsType!]!
  age: [AuthDashboardAgeType!]!
}

type AuthDashboardAgeByAppType {
  ageRange: String!
  count: Int!
  app: App!
}

type AuthDashboardRoleByAppType {
  role: UserRole!
  count: Int!
  app: App!
}

type AuthDashboardGenderByAppType {
  gender: Gender!
  count: Int!
  app: App!
}

type AuthDashboardMaritalStatusByAppType {
  maritalStatus: MaritalStatus!
  count: Int!
  app: App!
}

type AuthDashboardUsersByRegionByAppType {
  region: CountryEnum!
  count: Int!
  app: App!
}

type AuthDashboardMailValidationByAppType {
  isMailValid: Boolean!
  count: Int!
  app: App!
}

type AuthDashboardByAppType {
  gender: [AuthDashboardGenderByAppType!]!
  maritalStatus: [AuthDashboardMaritalStatusByAppType!]!
  usersByRegion: [AuthDashboardUsersByRegionByAppType!]!
  mailValidation: [AuthDashboardMailValidationByAppType!]!
  roles: [AuthDashboardRoleByAppType!]!
  usersByApp: [AuthDashboardUsersByAppsType!]!
  age: [AuthDashboardAgeByAppType!]!
}

type OnlineUsersByDeviceTypeType {
  deviceType: DeviceTypeEnum!
  onlineUsers: Int!
}

enum DeviceTypeEnum {
  TV
  TABLET
  CAMERA
  NO_DATA
  DESKTOP
  CONSOLE
  PHABLET
  WEARABLE
  SMARTPHONE
  PERIPHERAL
  CAR_BROWSER
  FEATURE_PHONE
  SMART_DISPLAY
  SMART_SPEAKER
  PORTABLE_MEDIA_PLAYER
}

type AuthDashboardPreviewByAppType {
  totalUsers: Int!
  onlineUsers: Int!
  onlineUsersByDeviceType: [OnlineUsersByDeviceTypeType!]!
}

type GetCockPitDashboardAnalyticsByAppType {
  totalUsers: Int!
  onlineUsers: Int!
}

type DailyCountType {
  total: Int!
  date: String!
}

type DurationsCountType {
  count: Int
  duration: Float
}

type GetCockPitDashboardUserAnalyticsByAppType {
  currentNewUsersCount: Int!
  previousNewUsersCount: Int!
  currentActiveUsersCount: Int!
  previousActiveUsersCount: Int!
  currentReturningUsersCount: Int!
  previousReturningUsersCount: Int!
  dailyNewUsersCount: [DailyCountType!]
  dailyActiveUsersCount: [DailyCountType!]
  dailyReturningUsersCount: [DailyCountType!]
}

type ClientDataType {
  name: String
  engine: String
  family: String
  version: String
  clientType: String
  engineVersion: String
  type: String
}

type OperatingSystemDataType {
  name: String
  version: String
  brand: String
  model: String
}

type MachineDataType {
  id: String
  deviceType: String
  brand: String
  model: String
}

type IosDataType {
  name: String
  model: String
  systemName: String
  systemVersion: String
  localizedModel: String
  utsnameMachine: String
  utsnameRelease: String
  utsnameSysname: String
  utsnameVersion: String
  utsnameNodename: String
  isPhysicalDevice: String
  identifierForVendor: String
}

type AndroidDataType {
  id: String
  host: String
  tags: String
  deviceType: String
  board: String
  brand: String
  model: String
  device: String
  display: String
  product: String
  hardware: String
  androidId: String
  bootloader: String
  fingerprint: String
  manufacturer: String
  versionBaseOS: String
  versionSdkInt: String
  versionRelease: String
  supportedAbis: [String!]
  versionCodename: String
  systemFeatures: [String!]
  isPhysicalDevice: String
  versionIncremental: String
  versionPreviewSdkInt: String
  versionSecurityPatch: String
  supported32BitAbis: [String!]
  supported64BitAbis: [String!]
}

type DeviceDataType {
  iosData: IosDataType!
  androidData: AndroidDataType!
  os: OperatingSystemDataType!
  client: ClientDataType!
  device: MachineDataType!
}

type LoginType {
  accessToken: String!
  expiresIn: Float!
  user: UserType!
}

type UserAuthenticationType {
  actionType: ActionTypeEnum!
  user: UserType!
}

enum ActionTypeEnum {
  LOGIN
  REGISTER
  APPLE_LOGIN
  GOOGLE_LOGIN
  LOGIN_FOR_APP
  FACEBOOK_LOGIN
  REGISTER_FOR_APP
}

type FormOwnerDtoType {
  pos: PointOfSaleType
  wholesaler: WholesalerType
  manufacturer: ManufacturerType
}

type JockerType {
  id: ID!
  title: String
  description: String
  icon: String
  media: MediaType
  target: TargetType
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ActivityTypeType {
  id: ID!
  title: String
  description: String
  icon: String
  media: MediaType
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ChallengeTypeTypeJocker {
  jocker: JockerType
  cost: String
}

type ChallengeTypeType {
  id: ID!
  title: String
  description: String
  rules: String
  icon: String
  media: MediaType
  minStep: Int
  minCheckPoints: Int
  minGiftValue: String

  # In days.
  claimReward: Int
  activityTypes: [ActivityTypeType!]
  jockers: [ChallengeTypeTypeJocker!]
  fees: String
  enable: Boolean
  target: TargetType
  createdAt: DateTime!
  updatedAt: DateTime!
}

type PerksType {
  discount: String!
  description: String
}

type LevelIntervalType {
  min: Int
  max: Int
}

type ReputationType {
  id: ID!
  reputationLevel: String
  lossAmount: Int!
  rank: Int!
  target: TargetType!
  picture: PictureType
  levelInterval: LevelIntervalType
  inactivityCycle: Int!
  nextLevelMax: Int
  perks: PerksType
  color: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ReputationWithoutTargetType {
  id: ID!
  reputationLevel: String
  lossAmount: Int!
  rank: Int!
  picture: PictureType
  levelInterval: LevelIntervalType
  inactivityCycle: Int!
  nextLevelMax: Int
  perks: PerksType
  color: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type AudienceCriteriaFieldType {
  field: AudienceCriteriaFieldEnum
  operators: [OperatorEnum!]
}

enum AudienceCriteriaFieldEnum {
  AGE
  STATE
  GENDER
  COUNTRY
  HOBBIES
  LANGUAGE
  LOCATION
  EDUCATION
  INTERESTS
  JOIN_DATE
  OCCUPATION
  MARITAL_STATUS
  REPUTATION_LEVEL
  QUANTITATIVE_CURRENT
  QUANTITATIVE_OVERALL
}

enum OperatorEnum {
  EQUAL
  GREATER
  BETWEEN
  DIFFERENT
  NOT_BETWEEN
  INCLUDED_IN
  AT_LEAST_ONE
  NOT_SPECIFIED
  NOT_INCLUDED_IN
}

type AudienceCriteriaType {
  id: ID!
  title: String
  description: String
  icon: String
  style: String
  enable: Boolean
  media: MediaType
  fields: [AudienceCriteriaFieldType!]
  createdAt: DateTime!
  updatedAt: DateTime!
}

type DeliveryZonePathType {
  lng: Float!
  lat: Float!
  order: Float!
}

type QuestActionDefinitionDefinitionTextBoxType {
  min: Int
  max: Int
}

type QuestActionDefinitionDefinitionRatingType {
  max: Int
  text: Boolean
}

type QuestActionDefinitionDefinitionCalculatedValuesType {
  minValue: Int
  maxValue: Int
  score: Boolean
}

type QuestActionDefinitionDefinitionCalculatedType {
  output: CalculatedOutputEnum
  show: Boolean
  formula: String
  values: [QuestActionDefinitionDefinitionCalculatedValuesType!]
}

enum CalculatedOutputEnum {
  NUMBER
  TEXT
}

type QuestActionDefinitionDefinitionDateType {
  outdated: Boolean
  interval: Boolean
}

type QuestActionDefinitionDefinitionContactType {
  firstname: Boolean
  lastname: Boolean
  email: Boolean
  phone: Boolean
  description: Boolean
  address: Boolean
  birthday: Boolean
  gender: Boolean
  civility: Boolean
  profession: Boolean
  academicLevel: Boolean
  Language: Boolean
}

type QuestActionDefinitionDefinitionNumberType {
  minValue: Int
  maxValue: Int
  interval: Boolean
}

type QuestActionDefinitionDefinitionApiParamsType {
  name: String
  type: String
}

type QuestActionDefinitionDefinitionApiType {
  link: Int
  method: ApiMethods
  auth: String
  secret: String
  params: [QuestActionDefinitionDefinitionApiParamsType!]
}

enum ApiMethods {
  GET
  POST
}

type QuestActionDefinitionDefinitionMatrixType {
  lines: String
  columns: String
}

type QuestActionDefinitionDefinitionToggleType {
  leftLabel: String
  rightLabel: String
}

type QuestActionDefinitionDefinitionChoicesType {
  maxResponses: Float
  personalised: Boolean
  unique: Boolean
  random: Boolean
  leaderboard: Boolean
  api: Boolean
  image: Boolean
  interaction: Boolean
  suggestions: [QuestionDtoType!]
}

type QuestActionDefinitionDefinitionSmileyType {
  levels: Int
}

type QuestActionDefinitionDefinitionScoreType {
  min: Int
}

type QuestActionDefinitionDefinitionLeadType {
  url: String
  image: String
}

type QuestActionDefinitionDefinitionVerificationItemContentType {
  rank: Int
}

type QuestActionDefinitionDefinitionVerificationItemType {
  verification: QuestActionDefinitionDefinitionVerificationItemContentType
  verified: QuestActionDefinitionDefinitionVerificationItemContentType
}

type QuestActionDefinitionDefinitionVerificationType {
  number: QuestActionDefinitionDefinitionVerificationItemType
  email: QuestActionDefinitionDefinitionVerificationItemType
}

type QuestActionDefinitionDefinitionVideoType {
  minSeconds: Int
}

type QuestActionDefinitionDefinitionSocialMediaType {
  socialMedia: SocialType
  action: SocialActionEnum
  socialContent: SocialContentTypeEnum
  url: String
}

enum SocialActionEnum {
  SHARE
  LIKE
}

enum SocialContentTypeEnum {
  PAGE
  PROFILE
  POST
  VIDEO
  STORY
  REEL
}

type QuestActionDefinitionDefinitionAppDownloadType {
  playstore: String
  appstore: String
  appgallery: String
}

type QuestActionDefinitionDefinitionType {
  textBox: QuestActionDefinitionDefinitionTextBoxType
  rating: QuestActionDefinitionDefinitionRatingType
  calculated: QuestActionDefinitionDefinitionCalculatedType
  date: QuestActionDefinitionDefinitionDateType
  contact: QuestActionDefinitionDefinitionContactType
  number: QuestActionDefinitionDefinitionNumberType
  api: QuestActionDefinitionDefinitionApiType
  matrix: QuestActionDefinitionDefinitionMatrixType
  toggle: QuestActionDefinitionDefinitionToggleType
  choices: QuestActionDefinitionDefinitionChoicesType
  smiley: QuestActionDefinitionDefinitionSmileyType
  score: QuestActionDefinitionDefinitionScoreType
  lead: QuestActionDefinitionDefinitionLeadType
  verification: QuestActionDefinitionDefinitionVerificationType
  video: QuestActionDefinitionDefinitionVideoType
  socialMedia: QuestActionDefinitionDefinitionSocialMediaType
  appDownload: QuestActionDefinitionDefinitionAppDownloadType
}

type QuestActionDefinitionType {
  id: ID!
  activityType: ActivityTypeType
  required: Boolean
  definition: QuestActionDefinitionDefinitionType
  createdAt: DateTime!
  updatedAt: DateTime!
}

type AudienceSegmentFilterZoneType {
  radius: Float
  type: ZoneTypesEnum
  paths: [DeliveryZonePathType!]
}

enum ZoneTypesEnum {
  Point
  Polygon
}

type AudienceSegmentFilterValuesType {
  startDate: DateTime
  endDate: DateTime
  minValue: String
  maxValue: String
  value: String
  values: [String!]
  zone: AudienceSegmentFilterZoneType
  languages: [LanguageType!]
  reputations: [ReputationType!]
  countries: [CountryType!]
  states: [StateType!]
}

type AudienceSegmentFilterFieldType {
  value: AudienceCriteriaFieldEnum
  action: QuestActionDefinitionType
}

type AudienceSegmentFilterType {
  field: AudienceSegmentFilterFieldType
  operator: OperatorEnum
  values: [AudienceSegmentFilterValuesType!]
}

type AudienceSegmentType {
  rank: Int
  criteria: AudienceCriteriaType
  filters: [AudienceSegmentFilterType!]
}

type AudienceType {
  id: ID!
  title: String
  description: String
  icon: String
  media: MediaType
  segments: [AudienceSegmentType!]
  target: TargetType
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ChallengeTypeWinner {
  rank: Int!
  reward: Float
}

type ChallengeTypeCheckpoint {
  checkpoint: Int
  amount: Float
}

type ChallengeType {
  id: ID!
  title: String
  description: String
  media: MediaType
  creator: UserType
  challengeType: ChallengeTypeType
  startDate: DateTime
  endDate: DateTime
  status: ChallengeStatusEnum
  winners: [ChallengeTypeWinner!]
  checkpoints: [ChallengeTypeCheckpoint!]
  maxAnswers: Int
  audience: AudienceType
  target: TargetType
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum ChallengeStatusEnum {
  DRAFT
  ONGOING
  FINISHED
}

type ChallengeStepType {
  id: ID!
  title: String
  description: String
  media: MediaType
  startDate: DateTime
  endDate: DateTime
  rank: Int
  randomize: Boolean
  challenge: ChallengeType
  createdAt: DateTime!
  updatedAt: DateTime!
}

type QuestionChoiceDtoType {
  item: String!
  enable: Boolean
}

type QuestionDtoType {
  id: ID!
  mandatory: Boolean
  title: String!
  description: String!
  choices: [QuestionChoiceDtoType!]!
  order: Int!
  type: QuestionTypeEnum!
  challengeStep: ChallengeStepType
  score: Boolean
  points: Int
  duration: Int
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum QuestionTypeEnum {
  SHORT_ANSWER
  PARAGRAPH
  MULTIPLE_CHOICE
  CHECKBOXES
  DROPDOWN
  PICTURE
  DATE
  TIME
}

type FormResponseType {
  id: ID!
  title: String!
  description: String!
  questions: [QuestionDtoType!]!
  owner: FormOwnerDtoType!
  type: FormType!
  status: FormStatus!
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum FormType {
  GUIDED
  AUTONOMOUS
}

enum FormStatus {
  DRAFT
  CHECKED
  ONGOING
  FINISHED
}

type AnswerDtoType {
  count: Int!
  answers: [String!]!
}

type TargetDtoType {
  pos: PointOfSaleType
  user: UserType
}

type ResponseDtoType {
  id: ID!
  target: TargetDtoType!
  executor: UserType!
  question: QuestionDtoType!
  answers: [String!]!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type SingleAnswerDtoType {
  count: Int!
  answer: String!
}

type AccessLoggerClientDataType {
  name: String
  engine: String
  family: String
  version: String
  clientType: String
  engineVersion: String
  type: String
}

type AccessLoggerOperatingSystemDataType {
  name: String
  version: String
  brand: String
  model: String
}

type AccessLoggerMachineDataType {
  id: String
  deviceType: String
  brand: String
  model: String
}

type AccessLoggerIosDataType {
  name: String
  model: String
  systemName: String
  systemVersion: String
  localizedModel: String
  utsnameMachine: String
  utsnameRelease: String
  utsnameSysname: String
  utsnameVersion: String
  utsnameNodename: String
  isPhysicalDevice: String
  identifierForVendor: String
}

type AccessLoggerAndroidDataType {
  id: String
  host: String
  tags: String
  deviceType: String
  board: String
  brand: String
  model: String
  device: String
  display: String
  product: String
  hardware: String
  androidId: String
  bootloader: String
  fingerprint: String
  manufacturer: String
  versionBaseOS: String
  versionSdkInt: String
  versionRelease: String
  supportedAbis: [String!]
  versionCodename: String
  systemFeatures: [String!]
  isPhysicalDevice: String
  versionIncremental: String
  versionPreviewSdkInt: String
  versionSecurityPatch: String
  supported32BitAbis: [String!]
  supported64BitAbis: [String!]
}

type AccessLoggerDeviceDataType {
  iosData: AccessLoggerIosDataType!
  androidData: AccessLoggerAndroidDataType!
  os: AccessLoggerOperatingSystemDataType!
  client: AccessLoggerClientDataType!
  device: AccessLoggerMachineDataType!
}

type AccessLoggerRequestType {
  host: String
  port: String
  token: String
  origin: String
  hostname: String
  pathname: String
  protocol: String
  variables: String
  url: String!
  query: String!
  operationName: String!
}

type ReduciblePriceType {
  beforeReduction: String
  afterReduction: String
}

type PriceCreditType {
  amount: String
  periodValue: Int
  periodCycle: RecurrenceType
}

enum RecurrenceType {
  HOURLY
  DAILY
  WEEKLY
  MONTHLY
  YEARLY
}

type PriceFullType {
  net: ReduciblePriceType
  gross: ReduciblePriceType
}

type TaxValueType {
  unit: String
  total: String
}

type LocationType {
  id: ID!
  name: String
  externalId: String
  media: MediaType
  tags: [String!]
  company: CompanyType
  address: FullAddressType
  locationType: LocationTypeEnum
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum LocationTypeEnum {
  OFFICE
  STORAGE
  FACTORY
  WAREHOUSE
}

type WarehouseType {
  id: ID!
  name: String
  media: MediaType
  tags: [String!]
  location: LocationType
  totalSurface: Float
  nonStorageSurface: Float
  externalId: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type StockPixelType {
  quantityToSellOnFacebook: Int
}

type StockRawType {
  id: ID!
  stockCapacity: Int!
  currentStock: Int!
  stockPercentage: String!
  minimumStockQuantity: Int!
  pixel: StockPixelType
  outOfStock: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type StockType {
  id: ID!
  stockCapacity: Int!
  currentStock: Int!
  stockPercentage: String!
  minimumStockQuantity: Int!
  pixel: StockPixelType
  outOfStock: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
  barcode: BarcodeType!
  target: TargetType!
  warehouse: WarehouseType
}

type MetaKeywordsType {
  name: String
  content: String
}

type CatalogueCategorySeoType {
  urlKey: String
  metaTitle: String
  metaDesription: String
  metaKeywords: [MetaKeywordsType!]
}

type CatalogueCategoryBaseType {
  id: ID!
  name: String
  description: String
  externalId: String
  pictures: [PictureType!]
  variety: ProductVarietyEnum
  parent: CatalogueCategoryBaseType
  portal: Boolean
  pickup: Boolean
  booking: Boolean
  delivery: Boolean
  hasChildren: Boolean!
  rank: Int
  layer: Int!
  seo: CatalogueCategorySeoType
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum ProductVarietyEnum {
  PRODUCT
  EQUIPMENT
  SERVICE
  VEHICULE
}

type CatalogueCategoryType {
  id: ID!
  name: String
  description: String
  externalId: String
  pictures: [PictureType!]
  variety: ProductVarietyEnum
  parent: CatalogueCategoryBaseType
  portal: Boolean
  pickup: Boolean
  booking: Boolean
  delivery: Boolean
  hasChildren: Boolean!
  rank: Int
  layer: Int!
  seo: CatalogueCategorySeoType
  createdAt: DateTime!
  updatedAt: DateTime!
  target: TargetType!
}

type CatalogueCategoryWithChildrenType {
  id: ID!
  name: String
  description: String
  externalId: String
  pictures: [PictureType!]
  variety: ProductVarietyEnum
  parent: CatalogueCategoryBaseType
  portal: Boolean
  pickup: Boolean
  booking: Boolean
  delivery: Boolean
  hasChildren: Boolean!
  rank: Int
  layer: Int!
  seo: CatalogueCategorySeoType
  createdAt: DateTime!
  updatedAt: DateTime!
  target: TargetType!
  children: [CatalogueCategoryWithChildrenType!]
}

type BrandType {
  id: ID
  name: String
  picture: PictureType
  externalId: String
  website: String
  target: TargetType
  manufacturer: ManufacturerType
  createdAt: DateTime!
  updatedAt: DateTime!
}

type TaxVaType {
  sign: TaxSignEnum!
  value: String
  type: DiscountType!
}

enum TaxSignEnum {
  POSITIVE
  NEGATIVE
}

type TaxType {
  id: ID!
  label: String
  externalId: String
  value: TaxVaType
  use: [TaxUseEnum!]
  product: Boolean
  company: CompanyType
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum TaxUseEnum {
  SALE
  PURCHASE
}

type PriceType {
  id: ID!
  label: String
  enable: Boolean
  company: CompanyType
  createdAt: DateTime!
  updatedAt: DateTime!
}

type AttributeValueBaseType {
  id: ID!
  label: String!
  externalId: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type AttributeValueBaseRawType {
  id: ID!
  label: String!
  externalId: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  attribute: AttributeBaseType!
}

type AttributeValueType {
  id: ID!
  label: String!
  externalId: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  target: TargetType!
  attribute: AttributeType!
}

type AttributeValueFilterType {
  id: ID!
  label: String!
  attribute: AttributeRawBaseType!
}

type AttributePixelType {
  pixelAttribute: String
}

type AttributeRawBaseType {
  id: ID!
  label: String!
}

type AttributeBaseType {
  id: ID!
  label: String!
  externalId: String!
  isRequired: Boolean
  isMultipleChoice: Boolean
  pixel: AttributePixelType
  variety: ProductVarietyEnum
  createdAt: DateTime!
  updatedAt: DateTime!
}

type AttributeWithValueFilterType {
  id: ID!
  label: String
  attributeValues: [FilterLabelFieldType!]
}

type AttributeType {
  id: ID!
  label: String!
  externalId: String!
  isRequired: Boolean
  isMultipleChoice: Boolean
  pixel: AttributePixelType
  variety: ProductVarietyEnum
  createdAt: DateTime!
  updatedAt: DateTime!
  target: TargetType
}

type AttributePaginateType {
  count: Int
  isLast: Boolean
  objects: [AttributeType!]!
}

type ProductAttributeType {
  id: ID!
  attribute: AttributeType!
  isRequired: Boolean!
  isMultipleChoice: Boolean!
  possibleValues: [String!]!
  reference: String!
  target: TargetType
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ProductAttributePaginateType {
  count: Int
  isLast: Boolean
  objects: [ProductAttributeType!]!
}

type InventoryCategoryType {
  id: ID!
  name: String!
  picture: PictureType
  layer: Int!
  rank: Int!
  hasChildren: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ProductPriceListType {
  price: PriceType
  value: String
}

type ProductTaxesType {
  tax: TaxType
  rank: Int
}

type ProductType {
  id: ID
  name: String
  externalId: String
  description: String
  descriptionList: [String!]
  specs: [ProductSpecsType!]
  tags: [String!]
  picture: PictureType
  pictures: [PictureType!]
  media: MediaType
  ean: String
  weight: Float
  price: String
  class: [ProductClassEnum!]
  structure: ProductStructureEnum
  rent: Boolean
  variety: ProductVarietyEnum
  wholesalerPrice: String
  factoryPrice: String
  tax: String
  taxes: [ProductTaxesType!]
  productAttributes: [ProductAttributeType!]

  # list of barcodes
  barcodes: [BarcodeType!]
  brand: BrandType
  category: [InventoryCategoryType!]
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum ProductClassEnum {
  TOP_PRODUCTS
  FEATURED_PRODUCTS
  NEW_ARRIVALS
  BEST_SELLERS
}

enum ProductStructureEnum {
  STOCKABLE
  CONSUMABLE
  SERVICE
}

type InternalProductAttributeInnerType {
  selectedValue: String
  price: String
  productAttribute: ProductAttributeType
}

type InternalProductAttributeType {
  attributes: [InternalProductAttributeInnerType!]
}

type InternalProductAttributesValuesBaseType {
  attributesValues: [AttributeValueBaseRawType!]
}

type InternalProductAttributesValuesType {
  attributesValues: [AttributeValueType!]
}

type InternalProductAttributesValuesFilterType {
  attributesValues: [AttributeValueFilterType!]
}

type InternalProductMaintenanceType {
  active: Boolean
  owner: UserType
  technician: UserType
  prevMaintenanceDuration: Int
  maintenanceDuration: Int
  expectedMeantime: Int
}

type GlobalCategoryProductType {
  googleCategory: GlobalCategoryType
  facebookCategory: GlobalCategoryType
}

type InternalProductType {
  id: ID
  name: String
  description: String
  descriptionList: [String!]
  specs: [ProductSpecsType!]
  externalId: String
  tags: [String!]
  sku: String
  condition: ProductConditionEnum
  status: ProductStatusEnum
  picture: PictureType
  pictures: [PictureType!]
  media: MediaType
  structure: ProductStructureEnum
  rent: Boolean
  variety: ProductVarietyEnum
  price: String
  priceBeforeReduction: String
  discount: DiscountDtoType
  product: ProductType
  target: TargetType!
  catalogueCategory: [CatalogueCategoryType!]
  globalCategory: GlobalCategoryProductType
  tax: String
  seo: CatalogueCategorySeoType
  brand: BrandType
  createdAt: DateTime!
  updatedAt: DateTime!
  class: [ProductClassEnum!]
  barcodes: [BarcodeType!]
}

enum ProductConditionEnum {
  NEW
  REFURBISHED
  USED
}

enum ProductStatusEnum {
  ACTIVE
  ARCHIVED
}

type InternalProductWithStockType {
  id: ID
  name: String
  description: String
  descriptionList: [String!]
  specs: [ProductSpecsType!]
  externalId: String
  tags: [String!]
  sku: String
  condition: ProductConditionEnum
  status: ProductStatusEnum
  picture: PictureType
  pictures: [PictureType!]
  media: MediaType
  structure: ProductStructureEnum
  rent: Boolean
  variety: ProductVarietyEnum
  price: String
  priceBeforeReduction: String
  discount: DiscountDtoType
  product: ProductType
  target: TargetType!
  catalogueCategory: [CatalogueCategoryType!]
  globalCategory: GlobalCategoryProductType
  tax: String
  seo: CatalogueCategorySeoType
  brand: BrandType
  createdAt: DateTime!
  updatedAt: DateTime!
  class: [ProductClassEnum!]
  barcodes: [BarcodeType!]
  stock: StockRawType
}

type InternalProductWithFavoriteStatusType {
  id: ID
  name: String
  description: String
  descriptionList: [String!]
  specs: [ProductSpecsType!]
  externalId: String
  tags: [String!]
  sku: String
  condition: ProductConditionEnum
  status: ProductStatusEnum
  picture: PictureType
  pictures: [PictureType!]
  media: MediaType
  structure: ProductStructureEnum
  rent: Boolean
  variety: ProductVarietyEnum
  price: String
  priceBeforeReduction: String
  discount: DiscountDtoType
  product: ProductType
  target: TargetType!
  catalogueCategory: [CatalogueCategoryType!]
  globalCategory: GlobalCategoryProductType
  tax: String
  seo: CatalogueCategorySeoType
  brand: BrandType
  createdAt: DateTime!
  updatedAt: DateTime!
  class: [ProductClassEnum!]
  barcodes: [BarcodeType!]
  isFavorite: Boolean
}

type InternalProductWithoutClassType {
  id: ID
  name: String
  description: String
  descriptionList: [String!]
  specs: [ProductSpecsType!]
  externalId: String
  tags: [String!]
  sku: String
  condition: ProductConditionEnum
  status: ProductStatusEnum
  picture: PictureType
  pictures: [PictureType!]
  media: MediaType
  structure: ProductStructureEnum
  rent: Boolean
  variety: ProductVarietyEnum
  price: String
  priceBeforeReduction: String
  discount: DiscountDtoType
  product: ProductType
  target: TargetType!
  catalogueCategory: [CatalogueCategoryType!]
  globalCategory: GlobalCategoryProductType
  tax: String
  seo: CatalogueCategorySeoType
  brand: BrandType
  createdAt: DateTime!
  updatedAt: DateTime!
  internalProductAttributes: InternalProductAttributeType
  barcodes: [BarcodeType!]
  ratings: String
}

type InternalProductByClassType {
  BEST_SELLERS: [InternalProductWithoutClassType!]
  NEW_ARRIVALS: [InternalProductWithoutClassType!]
  TOP_PRODUCTS: [InternalProductWithoutClassType!]
  FEATURED_PRODUCTS: [InternalProductWithoutClassType!]
}

type InternalProductWithoutClassWithFavoriteStatusType {
  id: ID
  name: String
  description: String
  descriptionList: [String!]
  specs: [ProductSpecsType!]
  externalId: String
  tags: [String!]
  sku: String
  condition: ProductConditionEnum
  status: ProductStatusEnum
  picture: PictureType
  pictures: [PictureType!]
  media: MediaType
  structure: ProductStructureEnum
  rent: Boolean
  variety: ProductVarietyEnum
  price: String
  priceBeforeReduction: String
  discount: DiscountDtoType
  product: ProductType
  target: TargetType!
  catalogueCategory: [CatalogueCategoryType!]
  globalCategory: GlobalCategoryProductType
  tax: String
  seo: CatalogueCategorySeoType
  brand: BrandType
  createdAt: DateTime!
  updatedAt: DateTime!
  internalProductAttributes: InternalProductAttributeType
  barcodes: [BarcodeType!]
  ratings: String
  isFavorite: Boolean
}

type InternalProductByClassTypeWithFavoriteStatus {
  BEST_SELLERS: [InternalProductWithoutClassWithFavoriteStatusType!]
  NEW_ARRIVALS: [InternalProductWithoutClassWithFavoriteStatusType!]
  TOP_PRODUCTS: [InternalProductWithoutClassWithFavoriteStatusType!]
  FEATURED_PRODUCTS: [InternalProductWithoutClassWithFavoriteStatusType!]
}

type InternalProductWithRatingsType {
  id: ID
  name: String
  description: String
  descriptionList: [String!]
  specs: [ProductSpecsType!]
  externalId: String
  tags: [String!]
  sku: String
  condition: ProductConditionEnum
  status: ProductStatusEnum
  picture: PictureType
  pictures: [PictureType!]
  media: MediaType
  structure: ProductStructureEnum
  rent: Boolean
  variety: ProductVarietyEnum
  price: String
  priceBeforeReduction: String
  discount: DiscountDtoType
  product: ProductType
  catalogueCategory: [CatalogueCategoryType!]
  tax: String
  seo: CatalogueCategorySeoType
  brand: BrandType
  createdAt: DateTime!
  updatedAt: DateTime!
  class: [ProductClassEnum!]
  barcodes: [BarcodeType!]
  target: TargetFilterType!
  ratings: String
}

type InternalProductWithRatingsWithFavoriteStatusType {
  id: ID
  name: String
  description: String
  descriptionList: [String!]
  specs: [ProductSpecsType!]
  externalId: String
  tags: [String!]
  sku: String
  condition: ProductConditionEnum
  status: ProductStatusEnum
  picture: PictureType
  pictures: [PictureType!]
  media: MediaType
  structure: ProductStructureEnum
  rent: Boolean
  variety: ProductVarietyEnum
  price: String
  priceBeforeReduction: String
  discount: DiscountDtoType
  product: ProductType
  catalogueCategory: [CatalogueCategoryType!]
  tax: String
  seo: CatalogueCategorySeoType
  brand: BrandType
  createdAt: DateTime!
  updatedAt: DateTime!
  class: [ProductClassEnum!]
  barcodes: [BarcodeType!]
  target: TargetFilterType!
  ratings: String
  isFavorite: Boolean
}

type BarcodePeriodCreditType {
  periodCycle: RecurrenceType!
  periodValue: Int!
  amount: String
}

type PixelBarcodeType {
  include: Boolean
}

type BarcodeBaseRawType {
  id: ID!
  barcode: String!
  name: String
  price: String
  priceCredit: [BarcodePeriodCreditType!]
  discount: DiscountDtoType
  condition: ProductConditionEnum
  status: ProductStatusEnum
  media: MediaType
  catalogueCategory: [CatalogueCategoryType!]
  maintenance: InternalProductMaintenanceType
  supplier: CompanyType
  pixel: PixelBarcodeType
  priceList: [ProductPriceListType!]
  taxes: [ProductTaxesType!]
  createdAt: DateTime!
  updatedAt: DateTime!
  productAttributesValues: InternalProductAttributesValuesBaseType
}

type BarcodeType {
  id: ID!
  barcode: String!
  name: String
  price: String
  priceCredit: [BarcodePeriodCreditType!]
  discount: DiscountDtoType
  condition: ProductConditionEnum
  status: ProductStatusEnum
  media: MediaType
  catalogueCategory: [CatalogueCategoryType!]
  maintenance: InternalProductMaintenanceType
  supplier: CompanyType
  pixel: PixelBarcodeType
  priceList: [ProductPriceListType!]
  taxes: [ProductTaxesType!]
  createdAt: DateTime!
  updatedAt: DateTime!
  product: ProductType
  internalProduct: InternalProductType
  productAttributesValues: InternalProductAttributesValuesType
}

type BarcodeWithStockDataType {
  id: ID!
  barcode: String!
  name: String
  price: String
  priceCredit: [BarcodePeriodCreditType!]
  discount: DiscountDtoType
  condition: ProductConditionEnum
  status: ProductStatusEnum
  media: MediaType
  catalogueCategory: [CatalogueCategoryType!]
  maintenance: InternalProductMaintenanceType
  supplier: CompanyType
  pixel: PixelBarcodeType
  priceList: [ProductPriceListType!]
  taxes: [ProductTaxesType!]
  createdAt: DateTime!
  updatedAt: DateTime!
  product: ProductType
  internalProduct: InternalProductType
  productAttributesValues: InternalProductAttributesValuesType
  currentStock: Int
  outOfStock: Boolean
}

type BarcodeWithStockType {
  id: ID!
  barcode: String!
  name: String
  price: String
  priceCredit: [BarcodePeriodCreditType!]
  discount: DiscountDtoType
  condition: ProductConditionEnum
  status: ProductStatusEnum
  media: MediaType
  catalogueCategory: [CatalogueCategoryType!]
  maintenance: InternalProductMaintenanceType
  supplier: CompanyType
  pixel: PixelBarcodeType
  priceList: [ProductPriceListType!]
  taxes: [ProductTaxesType!]
  createdAt: DateTime!
  updatedAt: DateTime!
  product: ProductType
  internalProduct: InternalProductType
  productAttributesValues: InternalProductAttributesValuesType
  stock: StockRawType
}

type BarcodeForTargetType {
  id: ID!
  barcode: String!
  name: String
  price: String
  priceCredit: [BarcodePeriodCreditType!]
  discount: DiscountDtoType
  condition: ProductConditionEnum
  status: ProductStatusEnum
  media: MediaType
  catalogueCategory: [CatalogueCategoryType!]
  maintenance: InternalProductMaintenanceType
  supplier: CompanyType
  pixel: PixelBarcodeType
  priceList: [ProductPriceListType!]
  taxes: [ProductTaxesType!]
  createdAt: DateTime!
  updatedAt: DateTime!
  productAttributesValues: InternalProductAttributesValuesType
}

type BarcodePaginateType {
  count: Int
  isLast: Boolean
  objects: [BarcodeType!]!
}

type BarcodeWithStockPaginatedType {
  count: Int
  isLast: Boolean
  objects: [BarcodeWithStockType!]!
}

type ProductPriceType {
  unitNet: String
  unitGross: String
  net: String
  gross: String
}

type OrderShoppingCartProductType {
  name: String
  target: TargetType
  taxValue: TaxValueType!
  price: ProductPriceType!
  deliveryMan: UserType
  quantity: Int!
  pickupTime: DateTime
  barcode: BarcodeType!
  orderProductStatus: OrderStatus!
}

enum OrderStatus {
  OPEN
  CONFIRMED
  ASSIGNED
  READY_FOR_PICKUP
  DELIVERED
  CANCELED
}

type MarketPlaceOrderShoppingCartType {
  target: TargetType
  products: [OrderShoppingCartProductType!]
  taxValue: ReduciblePriceType
  deliveryFees: String
  price: PriceFullType
  discount: DiscountDtoType
}

type MarketPlaceOrderDtoType {
  id: ID!
  number: String!
  user: UserType
  notes: String
  orderType: OrderTypeEnum
  installments: [InstallmentType!]
  deliveryAddress: FullAddressType
  hasInvoice: Boolean
  shoppingCart: MarketPlaceOrderShoppingCartType!
  orderTime: DateTime
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum OrderTypeEnum {
  ORDER_AHEAD
  PICKUP
  DELIVERY
  IN_HOUSE
}

type RemunerationDtoType {
  pocketType: PocketTypeEnum
  amount: String
}

enum PocketTypeEnum {
  QUANTITATIVE
  QUALITATIVE
}

type RemunerationWithReputationDtoType {
  qualitativeAmount: String!
  quantitativeAmount: String!
  reputationLevel: ReputationType
}

type QuestActionsRecurrenceType {
  enable: Boolean
  cycle: Int
}

type QuestPredefinedType {
  enable: Boolean
  action: QuestPredefinedActionsEnum
}

enum QuestPredefinedActionsEnum {
  COMPLETE_PROFILE
  ADD_WISHLIST
  REGISTER
  LOGIN
  NEWSLETTER
  SIGNUP
  PRODUCT_RATING
  PRODUCT_REVIEW
  SHARE_PRODUCT_FACEBOOK
  SHARE_BLOG_FACEBOOK
}

type QuestType {
  id: ID!
  title: String
  description: String
  media: MediaType
  category: QuestCategoryEnum
  predefined: QuestPredefinedType
  status: QuestStatusEnum
  recurrence: QuestActionsRecurrenceType
  remuneration: RemunerationDtoType
  activityType: ActivityTypeType
  creator: UserType
  sponsored: Boolean
  leaderboard: Boolean
  rewards: String
  maxAnswers: Int
  audience: AudienceType
  target: TargetType!
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum QuestCategoryEnum {
  INDUSTRY
  FAMILY
  FITNESS
  GASTRONOMY
}

enum QuestStatusEnum {
  DRAFT
  ONGOING
  ON_HOLD
  FINISHED
}

type QuestActionActionContentType {
  content: String
}

type QuestActionActionPerformedType {
  performed: Boolean
}

type QuestActionActionContactType {
  firstname: String
  lastname: String
  email: String
  phone: String
  description: String
  address: FullAddressType
  birthday: DateTime
  gender: Gender
  civility: MaritalStatus
  profession: String
  academicLevel: AcademicLevel
  Language: [LanguageType!]
}

type QuestActionActionDateType {
  startDate: DateTime
  endDate: DateTime
}

type QuestActionActionNumberType {
  from: Float
  to: Float
}

type QuestActionActionApiType {
  code: Float
  content: Float
}

type QuestActionActionVerificationContentType {
  verification: QuestActionActionPerformedType
  verified: QuestActionActionPerformedType
}

type QuestActionActionVerificationType {
  number: QuestActionActionVerificationContentType
  email: QuestActionActionVerificationContentType
}

type QuestActionActionChoicesType {
  responses: [ResponseDtoType!]
}

type QuestActionActionType {
  textBox: QuestActionActionContentType
  rating: QuestActionActionContentType
  calculated: QuestActionActionContentType
  date: QuestActionActionDateType
  contact: QuestActionActionContactType
  number: QuestActionActionNumberType
  api: QuestActionActionApiType
  matrix: QuestActionActionContentType
  toggle: QuestActionActionContentType
  choices: QuestActionActionChoicesType
  smiley: QuestActionActionContentType
  score: QuestActionActionContentType
  lead: QuestActionActionContentType
  verification: QuestActionActionVerificationType
  video: QuestActionActionPerformedType
  socialMedia: QuestActionActionPerformedType
  appDownload: QuestActionActionPerformedType
}

type QuestActionType {
  id: ID!
  status: QuestActionStatus!
  user: UserType!
  activity: QuestActivityType!
  action: QuestActionActionType!
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum QuestActionStatus {
  EXPIRED
  PERFORMED
  IN_PROGRESS
}

type IQuestActivityActivitiesConditionConditionActionType {
  definition: QuestActivityConditionType
  action: QuestActionActionType
}

enum QuestActivityConditionType {
  ACTION
  SCORE
}

type IQuestActivityActivitiesConditionConditionScoreType {
  operator: OperatorEnum
  value: OperatorEnum
}

type IQuestActivityActivitiesConditionConditionType {
  action: IQuestActivityActivitiesConditionConditionActionType
  score: IQuestActivityActivitiesConditionConditionScoreType
}

type IQuestActivityActivitiesConditionType {
  conditionType: QuestActivityConditionType
  condition: IQuestActivityActivitiesConditionConditionType
  transition: QuestActivityTransitionType
  endMessage: String
}

enum QuestActivityTransitionType {
  CONNECTION
  END
}

type IQuestActivityActivitiesTransitionType {
  title: String
  description: String
}

type IQuestActivityActivitiesType {
  action: QuestActionDefinitionType
  transition: IQuestActivityActivitiesTransitionType
  condition: IQuestActivityActivitiesConditionType
}

type QuestActivityType {
  id: ID!
  title: String
  description: String
  tags: [String!]
  media: MediaType
  quest: QuestType
  rank: Int
  activities: [IQuestActivityActivitiesType!]
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ActivityLogActionType {
  quest: QuestType
  activity: QuestActivityType
  order: MarketPlaceOrderDtoType
}

type ActivityLogAffectedType {
  user: UserType
  pos: PointOfSaleType
  wholesaler: WholesalerType
  manufacturer: ManufacturerType
}

type ActivityLogBalanceAmountType {
  qualitative: String
  quantitative: String
}

type ActivityLogBalanceType {
  sign: TaxSignEnum!
  amount: ActivityLogBalanceAmountType
}

type ActivityLogType {
  id: ID!
  balance: ActivityLogBalanceType
  action: ActivityLogActionType
  affected: ActivityLogAffectedType
  target: ActivityLogAffectedType
  activityType: ActivityLogTypeEnum
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum ActivityLogTypeEnum {
  CONVERSION
  ORDER_ADDED
  WALLET_TOPUP
  ONSITE_ACTIVITY
  QUEST_FULFILLED
  REPUTATION_LOST
  DEAL_ORDER_ADDED
  QUEST_ACTIVITY_FULFILLED
}

type ActivityLogPaginateType {
  count: Int
  isLast: Boolean
  objects: [ActivityLogType!]!
}

type RequestRequestorType {
  firstName: String
  lastName: String
  email: String
  phone: IPhoneType
  address: FullAddressType
}

type RequestCompanyType {
  name: String
  address: FullAddressType
  vatId: String
  registerNo: String
  licenceNo: String
  website: String
  email: String
  phone: IPhoneType
}

type RequestRequestType {
  subject: String
  content: String
}

type RequestType {
  id: ID!
  requestor: RequestRequestorType
  company: RequestCompanyType
  request: RequestRequestType
  type: RequestTypeEnum
  status: RequestStatusEnum
  target: TargetType
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum RequestTypeEnum {
  CONTACT
  DEMO
  PARTNER
}

enum RequestStatusEnum {
  REQUESTED
  TREATED
  CLOSED
}

type OriginType {
  id: ID!
  url: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type PartnerReferralType {
  id: ID!
  posTitle: String
  picture: PictureType
  address: FullAddressType
  referralReference: String
  content: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type CloudinaryResourceType {
  public_id: String
  format: String
  version: String
  resource_type: String
  type: String
  created_at: String
  bytes: String
  width: String
  height: String
  url: String
  secure_url: String
}

type CloudinarySignatureType {
  tags: String
  folder: String
  public_id: String
  timestamp: Float
  signature: String
}

type ShortcutType {
  id: ID!
  label: String!
  description: String
  icon: String!
  picture: PictureType
  link: String!
  router: Boolean!
  user: UserType!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type VersionType {
  id: ID!
  version: String!
  platform: PlatformEnum!
  requireUpdate: Boolean!
  versionContent: [VersionContentType!]!
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum PlatformEnum {
  IOS
  ANDROID
  WEB
  DESKTOP
}

type VersionContentType {
  contentType: VersionContentTypeEnum!
  content: String!
}

enum VersionContentTypeEnum {
  ADDED
  CHANGED
  FIXED
}

type VersionsPaginateType {
  count: Int
  isLast: Boolean
  objects: [VersionType!]!
}

type BookingAttributeType {
  id: ID!
  label: String!
  isRequired: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type SettingsAttributeType {
  value: String!
  attribute: BookingAttributeType!
}

type BookingType {
  id: ID!
  user: UserType!
  pos: PointOfSaleType!
  bookingNumber: Float
  instructions: String
  bookingTime: DateTime
  attributes: [SettingsAttributeType!]
  people: Int
  status: BookingStatusEnum
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum BookingStatusEnum {
  OPEN
  CONFIRMED
  CLOSED
  CANCELED
}

type AdhocNotificationType {
  title: String
  executed: Boolean
  executedAt: DateTime
  description: String
  picture: PictureType
}

type NotificationOnsiteConverterType {
  qualitativeAmountPushed: String
  quantitativeAmountPushed: String
}

type ActionType {
  reputationLoss: Float
  internalProduct: String
  onsite: NotificationOnsiteConverterType
  adhocNotification: AdhocNotificationType
  booking: BookingType
  subscription: String
  order: String
  adhocOrder: String
  table: String
  quest: String
  activity: String
}

type SubjectsType {
  pos: String
  user: String
  consumer: String
  deliveryMan: String
}

type SubjectsFullType {
  pos: PointOfSaleType
  user: UserType
  consumer: UserType
  deliveryMan: UserType
}

type NotificationType {
  id: ID!
  event: EventTypeEnum
  seen: Boolean
  executed: Boolean
  executedAt: DateTime
  createdAt: DateTime!
  updatedAt: DateTime!
  action: ActionType
  subjects: SubjectsType
}

enum EventTypeEnum {
  QUEST_FULFILLED
  QUEST_ACTIVITY_FULFILLED
  REPUTATION_LOST
  APP_LOG
  PUSH_AMOUNT
  ORDER_CREATED
  ADHOC_NOTIFICATION
  SUBSCRIPTION_APPROVED
  SUBSCRIPTION_REJECTED
  SUBSCRIPTION_REQUESTED
  PRODUCT_CANCELLED
  PRODUCT_STATUS_UPDATED
  PRODUCT_PAYMENT_STATUS_UPDATED
  WALLET_TOPUP
  WAITER_CALLED
  CALL_WAITER_FOR_CHECK
  DELIVERY_MAN_ASSIGNED
  DEAL_CONFIRMED
  BOOKING_CREATED
  BOOKING_CONFIRMED
  BOOKING_CANCELLED_BY_POS
  BOOKING_CANCELLED_BY_CONSUMER
}

type AdhocNotificationTestType {
  event: EventTypeEnum
  executed: Boolean
  executedAt: DateTime
  seen: Boolean
  action: ActionType
}

type UnseenNotificationCountType {
  count: Int!
}

type NotificationFullType {
  id: ID!
  event: EventTypeEnum
  seen: Boolean
  executed: Boolean
  executedAt: DateTime
  createdAt: DateTime!
  updatedAt: DateTime!
  action: ActionType
  subjects: SubjectsFullType
}

type NotificationResponse {
  success: Boolean!
}

type GroupInviteType {
  id: ID!
  group: GroupType
  requestor: UserType
  status: GroupInviteStatusEnum
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum GroupInviteStatusEnum {
  PENDING
  CONFIRMED
  CANCELED
  REJECTED
}

type IsMemberOfGroupType {
  isMember: Boolean!
  status: GroupInviteStatusEnum
}

type GroupInvitePaginateType {
  count: Int
  isLast: Boolean
  objects: [GroupInviteType!]!
}

type GroupLeaderboardBaseType {
  user: UserType!
  group: GroupType!
  credit: String!
  rank: Int!
  rankDifference: Int!
  effectiveDate: DateTime!
}

type GroupLeaderboardType {
  user: UserType!
  group: GroupType!
  credit: String!
  rank: Int!
  rankDifference: Int!
  effectiveDate: DateTime!
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type GroupLeaderboardPaginatedType {
  count: Int
  isLast: Boolean
  objects: [GroupLeaderboardType!]!
}

type GroupLeaderboardBasePaginatedType {
  count: Int
  isLast: Boolean
  objects: [GroupLeaderboardBaseType!]!
}

type FollowType {
  id: ID!
  user: UserType!
  target: TargetWithGroupType!
}

type IsFollowingType {
  isFollowing: Boolean!
}

type MembersType {
  users: [UserType!]
}

type LastMessageType {
  text: String
  gif: String
  sticker: String
  media: MessageMediaType
  location: LonLatType
  custom: CustomMessageType
  unread: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

type MessageGroupWallpaperType {
  picture: PictureType
  gradientColors: [String!]
  assetImage: String
}

type MessageGroupType {
  id: ID!
  name: String
  mute: Boolean
  creator: UserType
  profilePicture: PictureType
  wallpaper: MessageGroupWallpaperType
  sound: MessageSoundEnum
  status: MessageGroupStatusEnum
  type: MessageGroupTypeEnum
  members: MembersType
  lastMessage: LastMessageType
  unreadCount: Int
  isDirectMessage: Boolean
  target: TargetType
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum MessageSoundEnum {
  DEFAULT
  NONE
  AURORA
}

enum MessageGroupStatusEnum {
  ACTIVE
  ARCHIVED
}

enum MessageGroupTypeEnum {
  SUPPORT
  INTERNAL
}

type MessageGroupPaginateType {
  count: Int
  isLast: Boolean
  objects: [MessageGroupType!]!
}

type MessageMediaType {
  picture: [PictureType!]
  video: [PictureType!]
}

type CustomMessageType {
  id: String
  type: String
}

type MessageType {
  id: ID!
  text: String
  gif: String
  sticker: String
  custom: CustomMessageType
  media: MessageMediaType
  location: LonLatType
  messageGroup: MessageGroupType!
  sender: UserType!
  seenBy: [UserType!]
  createdAt: DateTime!
  updatedAt: DateTime!
}

type UnseenMessagesCountType {
  unseenMessagesCount: Int!
}

type MessagePaginateType {
  count: Int
  isLast: Boolean
  objects: [MessageType!]!
}

type MessageMediaPaginateType {
  count: Int
  isLast: Boolean
  objects: [PictureType!]!
}

type AccountType {
  id: ID!
  expiresAt: DateTime
  user: UserType
  targets: TargetsType
  createdAt: DateTime!
  updatedAt: DateTime!
}

type AccountPaginateType {
  count: Int
  isLast: Boolean
  objects: [AccountType!]!
}

type CompanyPaginateType {
  count: Int
  isLast: Boolean
  objects: [CompanyType!]!
}

type CompanyContactType {
  id: ID!
  firstName: String
  lastName: String
  email: String
  phone: IPhoneType
  dateOfBirth: DateTime
  chatContact: [SocialValueType!]
  socialMedia: [SocialValueType!]
  media: MediaType
  tags: [String!]
  lastContacted: DateTime
  leadScore: String
  externalId: String
  company: CompanyType
  address: FullAddressType
  createdAt: DateTime!
  updatedAt: DateTime!
}

type CompanySettingsPurchaseNoteType {
  reference: DocumentReferenceModelEnum
  prefix: String
  note: String
}

enum DocumentReferenceModelEnum {
  WITH_PREFIX
  WITH_PREFIX_AND_DATE
  WITH_DATE
  WITH_DATE_WITHOUT_HYPHEN
  WITHOUT_PREFIX
}

type CompanySettingsPurchaseType {
  inventory: CompanySettingsPurchaseNoteType
  order: CompanySettingsPurchaseNoteType
  invoice: CompanySettingsPurchaseNoteType
  deliveryNote: CompanySettingsPurchaseNoteType
}

type CompanySettingsSaleQuotationValidityType {
  period: String
  cycle: String
}

type CompanySettingsSaleQuotationType {
  reference: DocumentReferenceModelEnum
  prefix: String
  label: String
  validity: CompanySettingsSaleQuotationValidityType
  color: String
  note: String
}

type CompanySettingsSaleType {
  quotation: CompanySettingsSaleQuotationType
  order: CompanySettingsSaleQuotationType
  invoice: CompanySettingsSaleQuotationType
  deliveryNote: CompanySettingsSaleQuotationType
  issueNote: CompanySettingsSaleQuotationType
}

type CompanySettingsTicketsType {
  prefix: String
}

type CompanySettingsType {
  id: ID!
  sale: CompanySettingsSaleType
  purchase: CompanySettingsPurchaseType
  tickets: CompanySettingsTicketsType
  logistic: CompanySettingsTicketsType
  company: CompanyType
  documentLogo: PictureType
  createdAt: DateTime!
  updatedAt: DateTime!
}

type DepartmentBaseType {
  id: ID!
  name: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type DepartmentType {
  id: ID!
  name: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  target: TargetType!
}

type AssigneeDtoType {
  user: UserType
  pos: PointOfSaleType
  wholesaler: WholesalerType
  manufacturer: ManufacturerType
}

type ModulesDefinitionType {
  id: ID!
  name: String!
  target: TargetTypeEnum
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum TargetTypeEnum {
  POS
  MANUFACTURER
  USER
}

type ModulesAssignmentType {
  id: ID!
  module: ModulesDefinitionType!
  assignee: AssigneeDtoType
  createdAt: DateTime!
  updatedAt: DateTime!
}

type SupplierType {
  id: ID!
  reference: String!
  externalId: String!
  supplier: TargetType!
  target: TargetType!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ComplaintTargetType {
  user: UserType
  pos: PointOfSaleType
  wholesaler: WholesalerType
  manufacturer: ManufacturerType
}

type ComplaintType {
  id: ID!
  reporter: UserType!
  report: String!
  target: ComplaintTargetType!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type BrandPaginateType {
  count: Int
  isLast: Boolean
  objects: [BrandType!]!
}

type ProductFilterType {
  createdAtRange: DateRangeType
  updatedAtRange: DateRangeType
  priceRange: PriceRangeType

  # list of brands
  brands: [BrandType!]

  # list of inventoryCategories
  categories: [InventoryCategoryType!]

  # list of productAttributes
  productAttributes: [ProductAttributeType!]

  # list of barcodes
  barcodes: [BarcodeType!]
  structure: [ProductStructureEnum!]
  variety: [ProductVarietyEnum!]
  rent: Boolean
}

type ProductPaginateType {
  count: Int
  isLast: Boolean
  objects: [ProductType!]!
}

type ProductPaginateWithFilterType {
  count: Int
  isLast: Boolean
  filter: ProductFilterType
  objects: [ProductType!]!
}

type ProductRatingDefinitionType {
  id: ID
  reviewType: String
  active: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ByMarkRatingType {
  mark: Int!
  count: Int!
}

type ProductRatingType {
  id: ID!
  mark: Int!
  comment: String
  user: UserType!
  reviewType: ProductRatingDefinitionType!
  product: ProductType!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type InventoryCategoryCountType {
  id: String
  name: String
  picture: PictureType
  layer: Int
  rank: Int
  parent: String
  createdAt: DateTime!
  updatedAt: DateTime!
  numberOfProducts: Int
}

type NumberOfInventoryCategoriesType {
  layer: Int!
  numberOfInventoryCategories: Int!
}

type PriceRangeCountType {
  numberOfProducts: Int!
  priceRange: [Float!]
}

type NumberOfProductsInventoryDashboardType {
  total: Int
  byInventoryCategory: [InventoryCategoryCountType!]!
  byPriceRange: [PriceRangeCountType!]!
  byWholesalerPriceRange: [PriceRangeCountType!]!
  byFactoryPriceRange: [PriceRangeCountType!]!
}

type InventoryCategoryPaginateType {
  count: Int
  isLast: Boolean
  objects: [InventoryCategoryType!]!
}

type ProductsByCatalogueCategoryCountType {
  id: ID!
  name: String
  description: String
  externalId: String
  pictures: [PictureType!]
  variety: ProductVarietyEnum
  parent: CatalogueCategoryBaseType
  portal: Boolean
  pickup: Boolean
  booking: Boolean
  delivery: Boolean
  hasChildren: Boolean!
  rank: Int
  layer: Int!
  seo: CatalogueCategorySeoType
  createdAt: DateTime!
  updatedAt: DateTime!
  numberOfProducts: Int!
}

type POSByPOSCategoryCountType {
  id: ID!
  name: String
  mapPicture: String
  picture: PictureType
  createdAt: DateTime!
  updatedAt: DateTime!
  numberOfPos: Int!
}

type AccountsByRoleCountType {
  numberOfAccounts: Int!
  role: UserRole!
}

type RolesCountType {
  numberOfPosRoles: Int!
  numberOfManufacturersRoles: Int!
  numberOfWholesalersRoles: Int!
  countByRoles: [AccountsByRoleCountType!]!
}

type AccountsCountType {
  total: Int!
  totalNumberOfPosAccounts: Int!
  totalNumberOfWholesalerAccounts: Int!
  totalNumberOfManufacturerAccounts: Int!
}

type InternalProductsByCatalogueCategoryCountType {
  id: ID!
  name: String
  description: String
  externalId: String
  pictures: [PictureType!]
  variety: ProductVarietyEnum
  parent: CatalogueCategoryBaseType
  portal: Boolean
  pickup: Boolean
  booking: Boolean
  delivery: Boolean
  hasChildren: Boolean!
  rank: Int
  layer: Int!
  seo: CatalogueCategorySeoType
  createdAt: DateTime!
  updatedAt: DateTime!
  numberOfProducts: Int!
}

type InternalProductsByInventoryCategoryCountType {
  id: ID!
  name: String!
  picture: PictureType
  layer: Int!
  rank: Int!
  hasChildren: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
  numberOfProducts: Int!
}

type InternalProductsByPOSCountType {
  id: ID!
  name: String
  title: String
  subtitle: String
  description: String
  tags: [String!]
  brandColor: String
  reference: String
  published: Boolean
  picture: PictureType
  outsidePictures: [PictureType!]
  insidePictures: [PictureType!]
  openingHours: OpeningHoursType
  specialOffers: [SpecialOfferType!]
  email: [String!]
  contactEmails: [String!]
  currency: Currency
  languages: [LanguageType!]
  phone: [String!]
  website: String
  chatContact: [SocialValueType!]
  socialMedia: [SocialValueType!]
  averageCustomers: Float
  turnover: String
  locations: [FullAddressType!]
  isFollowed: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
  numberOfPosProducts: Int!
}

type InternalProductsByWholesalerCountType {
  id: ID!
  name: String
  description: String
  address: FullAddressType
  picture: PictureType
  email: String
  website: String
  phone: IPhoneType
  contactEmails: [String!]
  fax: IPhoneType
  createdAt: DateTime!
  updatedAt: DateTime!
  numberOfWholesalerProducts: Int!
}

type InternalProductsByManufacturerCountType {
  id: ID!
  name: String
  description: String
  picture: PictureType
  externalId: String
  address: FullAddressType
  email: String
  website: String
  contactEmails: [String!]
  createdAt: DateTime!
  updatedAt: DateTime!
  numberOfManufacturerProducts: Int!
}

type NumberOfInternalProductsType {
  total: Int!
  byPos: [InternalProductsByPOSCountType!]!
  byWholesalers: [InternalProductsByWholesalerCountType!]!
  byManufacturers: [InternalProductsByManufacturerCountType!]!
  byCatalogueCategory: [InternalProductsByCatalogueCategoryCountType!]!
  byInventoryCategory: [InternalProductsByInventoryCategoryCountType!]!
}

type NumberOfProductsType {
  total: Int!
  byCatalogueCategory: [ProductsByCatalogueCategoryCountType!]!
  byInventoryCategory: [InventoryCategoryCountType!]!
}

type NumberOfPointOfSalesType {
  total: Int!
  byPosCategory: [POSByPOSCategoryCountType!]!
}

type CorporateUsersStatsType {
  current: Int!
  previous: Int!
  percentage: Float!
}

type PeriodStatsType {
  date: String!
  total: Float!
}

type TotalAndInPeriodCountsType {
  inPeriod: Int!
  total: Int!
}

type StockStatsType {
  total: Int!
  daily: [PeriodStatsType!]!
}

type StocksCountType {
  inPeriod: Int!
  total: Int!
  inStock: StockStatsType!
  outOfStock: StockStatsType!
}

type RatingsCountType {
  inPeriod: Int!
  total: Int!
  oneStarDaily: [PeriodStatsType!]!
  twoStarsDaily: [PeriodStatsType!]!
  threeStarsDaily: [PeriodStatsType!]!
  fourStarsDaily: [PeriodStatsType!]!
  fiveStarsDaily: [PeriodStatsType!]!
}

type VisitsFieldType {
  current: Int!
  previous: Int!
  percentage: Float!
  weeklyVisits: [PeriodStatsType!]!
}

type ConversionsFieldType {
  current: Int!
  previous: Int!
  percentage: Float!
  weeklyConversions: [PeriodStatsType!]!
}

type ImpressionsFieldType {
  current: Int!
  previous: Int!
  percentage: Float!
  weeklyImpressions: [PeriodStatsType!]!
}

type WholesalerPaginateType {
  count: Int
  isLast: Boolean
  objects: [WholesalerType!]!
}

type BrandValidationType {
  headersValid: Boolean!
  isIdComplete: Boolean!
  isNameComplete: Boolean!
  overallValidation: Boolean!
  length: Int!
}

type BarcodeValidationType {
  headersValid: Boolean
  isIdComplete: Boolean
  isNameComplete: Boolean
  isProductsComplete: Boolean
  isPricesComplete: Boolean
  overallValidation: Boolean
  length: Int
  numBarcodesWithAttributes: Int
}

type ProductValidationType {
  headersValid: Boolean
  isIdComplete: Boolean
  isNameComplete: Boolean
  isCategoriesComplete: Boolean
  isBrandsComplete: Boolean
  isVATComplete: Boolean
  overallValidation: Boolean
  length: Int
}

type AttributesValidationType {
  headersValid: Boolean
  isIdComplete: Boolean
  isLabelComplete: Boolean
  isRequiredComplete: Boolean
  isMultipleComplete: Boolean
  overallValidation: Boolean
  length: Int
}

type CategoriesValidationType {
  headersValid: Boolean
  isIdComplete: Boolean
  isLayerComplete: Boolean
  isRankComplete: Boolean
  isNameComplete: Boolean
  isParentComplete: Boolean
  overallValidation: Boolean
  length: Int
}

type AttributesValuesValidationType {
  headersValid: Boolean
  isIdComplete: Boolean
  isValueComplete: Boolean
  isAttributeComplete: Boolean
  overallValidation: Boolean
  length: Int
}

type StockValidationType {
  headersValid: Boolean
  isBarcodeComplete: Boolean
  isMinimumComplete: Boolean
  isCapacityComplete: Boolean
  isStockComplete: Boolean
  overallValidation: Boolean
  length: Int
}

type ManufacturerPaginateType {
  count: Int
  isLast: Boolean
  objects: [ManufacturerType!]!
}

type IsUserNearPOSDtoType {
  isUserNearPOS: Boolean!
}

type PointOfSalePaginateType {
  count: Int
  isLast: Boolean
  objects: [PointOfSaleType!]!
}

type MonthDaysType {
  month: Int!
  days: [Int!]
}

type TimeFromToType {
  from: String
  to: String
}

type BookingTypeType {
  id: ID
  index: Int
  name: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type BookingsStatusesCountType {
  OPEN: Int!
  CLOSED: Int!
  CANCELED: Int!
  CONFIRMED: Int!
}

type BookingsSourcesCountType {
  APP: Int!
  EMAIL: Int!
  PHONE: Int!
  FACEBOOK: Int!
  INSTAGRAM: Int!
}

type BookingsCountType {
  total: Int!
  numberOfPeople: [NumberOfPeopleCountType!]!
  bookingStatuses: BookingsStatusesCountType!
  bookingSources: BookingsSourcesCountType!
}

type NumberOfPeopleCountType {
  numberOfBookings: Int!
  numberOfPeopleRange: [Int!]!
}

type POSComissionType {
  id: ID!
  pos: PointOfSaleType
  walletComission: String
  marketplaceComission: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type POSContactRequestType {
  id: ID!
  pos: PointOfSaleType
  firstName: String!
  lastName: String!
  email: String!
  phoneNumber: String
  companyName: String
  subject: String!
  content: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type CorporateUserType {
  id: ID!
  email: String
  picture: PictureType
  pictures: [PictureType!]
  covers: [PictureType!]
  roles: [UserRole!]
  username: String
  firstName: String
  status: UserStatus
  title: String
  about: String
  lastName: String
  apps: [App!]
  maritalStatus: MaritalStatus
  gender: Gender
  languages: [LanguageType!]
  education: [UserEducationType!]
  work: [UserWorkType!]
  lived: [StateType!]
  hobbies: [String!]
  interests: [String!]
  isMailValid: Boolean
  plugged: Boolean
  hasAutoGeneratedEmail: Boolean
  dateOfBirth: DateTime
  phoneNumber: String
  phone: PhoneType
  chatContact: [SocialValueType!]
  socialMedia: [SocialValueType!]
  socialLoginData: SocialLoginDataType
  nationality: CountryType
  locale: String
  placeOfBirth: String
  residentialAddress: [FullAddressType!]
  shippingAddress: [FullAddressType!]
  billingAddress: [FullAddressType!]
  mobileTheme: MobileThemesEnum
  source: SourcesEnum
  newsletterSubs: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
  target: TargetType
}

type CorporateUserPaginateType {
  count: Int
  isLast: Boolean
  objects: [CorporateUserType!]!
}

type CorporateRatingDefinitionType {
  id: ID
  reviewType: String
}

type CorporateRatingType {
  id: ID!
  mark: Int!
  comment: String
  product: InternalProductType
  user: UserType!
  reviewType: CorporateRatingDefinitionType!
  target: TargetType!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type CorporateRatingAssignmentType {
  id: ID
  active: Boolean
  target: TargetType
  reviewDefinition: CorporateRatingDefinitionType
  createdAt: DateTime!
  updatedAt: DateTime!
}

type PromotionProductsType {
  barcode: BarcodeType!
  discount: DiscountDtoType!
}

type PromotionProductsWithInternalProductType {
  barcode: BarcodeBaseRawType!
  discount: DiscountDtoType!
  internalProduct: InternalProductType!
}

type PromotionType {
  id: ID!
  startDate: DateTime!
  endDate: DateTime!
  status: PromotionStatusEnum!
  target: TargetType!
  createdAt: DateTime!
  updatedAt: DateTime!
  promotion: [PromotionProductsType!]!
}

enum PromotionStatusEnum {
  DRAFT
  ONGOING
  EXPIRED
}

type PromotionWithInternalProductType {
  id: ID!
  startDate: DateTime!
  endDate: DateTime!
  status: PromotionStatusEnum!
  target: TargetType!
  createdAt: DateTime!
  updatedAt: DateTime!
  promotion: [PromotionProductsWithInternalProductType!]!
}

type BarcodeFilterResponseType {
  createdAtRange: DateRangeType
  priceRange: PriceRangeType

  # list of catalogueCategories
  catalogueCategories: [FilterNameFieldType!]
}

type InternalProductFilterType {
  createdAtRange: DateRangeType
  updatedAtRange: DateRangeType
  priceRange: PriceRangeType

  # list of brands
  brands: [FilterNameFieldType!]

  # list of catalogueCategories
  catalogueCategories: [FilterNameFieldType!]

  # list of AttributeValues
  productAttributesValues: [AttributeWithValueFilterType!]
  targets: TargetsType
}

type InternalProductPaginateType {
  count: Int
  isLast: Boolean
  objects: [InternalProductType!]!
}

type InternalProductWithFavoriteStatusPaginateType {
  count: Int
  isLast: Boolean
  objects: [InternalProductWithFavoriteStatusType!]!
}

type BarcodesPaginatedWithFilterType {
  count: Int
  isLast: Boolean
  filter: BarcodeFilterResponseType
  objects: [BarcodeType!]!
}

type InternalProductPaginateWithFilterType {
  count: Int
  isLast: Boolean
  filter: InternalProductFilterType
  objects: [InternalProductType!]!
}

type InternalProductWithRatingsPaginateWithFilterType {
  count: Int
  isLast: Boolean
  filter: InternalProductFilterType
  objects: [InternalProductWithRatingsType!]!
}

type InternalProductWithRatingsPaginateWithFavoriteStatusWithFilterType {
  count: Int
  isLast: Boolean
  filter: InternalProductFilterType
  objects: [InternalProductWithRatingsWithFavoriteStatusType!]!
}

type RecentlyViewedType {
  id: ID!
  user: UserType!
  product: InternalProductType!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type CompareProductType {
  id: ID!
  user: UserType!
  products: InternalProductType!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type FeaturedCorporateType {
  id: ID!
  rank: Int!
  pos: PointOfSaleType
  wholesaler: WholesalerType
  manufacturer: ManufacturerType
  createdAt: DateTime!
  updatedAt: DateTime!
}

type CatalogueCategoryPaginateType {
  count: Int
  isLast: Boolean
  objects: [CatalogueCategoryType!]!
}

type CorporateUserCardType {
  id: ID!
  user: UserType!
  target: TargetType!
  identifier: String!
  cardType: CardTypeEnum!
  validUntil: DateTime!
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum CardTypeEnum {
  PHYSICAL
  VIRTUAL
}

type GenerateUserCardType {
  virtualCard: CorporateUserCardType
  physicalCard: CorporateUserCardType
}

type CorporateUserCardFullPaginatedType {
  count: Int
  isLast: Boolean
  objects: [CorporateUserCardType!]!
}

type MarketPlaceProductType {
  id: ID!
  product: ProductType!
  internalProducts: [InternalProductType!]!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type MarketPlaceProductFilterType {
  createdAtRange: DateRangeType
  updatedAtRange: DateRangeType
  priceRange: PriceRangeType

  # list of brands
  brands: [BrandType!]

  # list of inventoryCategories
  categories: [InventoryCategoryType!]
  targets: TargetsType
}

type AdhocCorporateNotificationType {
  title: String
  executed: Boolean
  executedAt: DateTime
  description: String
  picture: PictureType
}

type CorporateNotificationOnsiteConverterType {
  qualitativeAmountPushed: String
  quantitativeAmountPushed: String
}

type CorporateActionType {
  reputationLoss: Float
  internalProduct: String
  onsite: CorporateNotificationOnsiteConverterType
  adhocNotification: AdhocCorporateNotificationType
  booking: BookingType
  subscription: String
  order: String
  adhocOrder: String
  table: String
  quest: String
  activity: String
}

type CorporateNotificationType {
  id: ID!
  event: EventTypeEnum
  seen: Boolean
  executed: Boolean
  executedAt: DateTime
  user: UserType!
  target: TargetType!
  createdAt: DateTime!
  updatedAt: DateTime!
  action: CorporateActionType
}

type SEOType {
  id: ID!
  target: TargetType!
  googleAnalyticsId: String
  titleTag: String
  metaDescriptionTag: String
  headerTags: [TagType!]
  createdAt: DateTime!
  updatedAt: DateTime!
}

type SeoComponentType {
  metaTitle: String
  metaDesription: String
  metaKeywords: [TagType!]
}

type BlogType {
  id: ID!
  target: TargetType!
  author: UserType!
  status: String!
  title: String!
  url: String
  tags: [String!]
  seo: SeoComponentType
  pictures: [PictureType!]
  sectionData: [BlogDataType!]
  createdAt: DateTime!
  updatedAt: DateTime!
}

type BlogDataType {
  sectionReference: String
  sectionTitle: String
  sectionContent: String
  sectionPictures: [PictureType!]
}

type LandingPagesType {
  id: ID!
  target: TargetType!
  pageType: LandingPageTypeEnum!
  pageReference: String!
  pageTitle: String!
  status: String!
  pageDescription: String
  url: String
  tags: [String!]
  seo: SeoComponentType
  sectionData: [LandingPagesDataType!]
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum LandingPageTypeEnum {
  ABOUT
  CONTACT
  PRIVACY
  TERMS
  RETURN_EXCHANGE
  SHIPPING
  COPYRIGHT
  FAQ
  PROJECT
  CAREER
  PROJECTS
  BLOG
}

type LandingPagesDataType {
  sectionReference: String
  sectionTitle: String
  sectionContent: String
  sectionPictures: [PictureType!]
}

type SlidesType {
  id: ID!
  target: TargetType!
  reference: String
  visualType: SlideVisualTypeEnum
  content: [SlidesContentType!]
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum SlideVisualTypeEnum {
  PICTURE
  ICON
}

type SlidesContentType {
  image: PictureType
  icon: String
  title: String
  description: String
  calltoaction: String
}

type VisualsFaviconType {
  size16: PictureType
  size32: PictureType
  size57: PictureType
  size60: PictureType
  size72: PictureType
  size76: PictureType
  size96: PictureType
  size114: PictureType
  size120: PictureType
  size144: PictureType
  size152: PictureType
  size180: PictureType
  size192: PictureType
}

type VisualsType {
  id: ID!
  target: TargetType!
  pageTitle: String
  logo: PictureType
  wide: PictureType
  square: PictureType
  favicon: VisualsFaviconType
  createdAt: DateTime!
  updatedAt: DateTime!
}

type JobDescriptionType {
  description: String
  descriptionList: [String!]
}

type JobSpecsType {
  key: JobDefinitionSpecEnum
  value: String
}

enum JobDefinitionSpecEnum {
  SALARY
  PERKS
  HOLIDAYS
  SKILLS
  LOCATION
  HOMEOFFICE
}

type JobDefinitionBaseType {
  id: ID!
  title: String!
  status: JobDefinitionStatusEnum!
  department: DepartmentBaseType!
  specs: [JobSpecsType!]
  description: JobDescriptionType
  responsibility: JobDescriptionType
  offer: JobDescriptionType
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum JobDefinitionStatusEnum {
  DRAFT
  ONGOING
  HIRED
  CANCELED
}

type JobDefinitionType {
  id: ID!
  title: String!
  status: JobDefinitionStatusEnum!
  specs: [JobSpecsType!]
  description: JobDescriptionType
  responsibility: JobDescriptionType
  offer: JobDescriptionType
  createdAt: DateTime!
  updatedAt: DateTime!
  target: TargetType!
  department: DepartmentType!
}

type DocumentContentType {
  type: ContentTypeType
  base64: String
}

type DocumentType {
  id: ID!
  name: String!
  content: DocumentContentType
  size: Float
  owner: UserType
  createdAt: DateTime!
  updatedAt: DateTime!
}

type JobApplicationBaseType {
  id: ID!
  firstName: String!
  lastName: String!
  email: String!
  message: String!
  cv: DocumentType
  cover: DocumentType
  status: JobApplicationStatusEnum!
  jobDefinition: JobDefinitionBaseType!
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum JobApplicationStatusEnum {
  NEW
  NOT_CONSIDERED
  SHORTLISTED
  HIRED
}

type JobApplicationType {
  id: ID!
  firstName: String!
  lastName: String!
  email: String!
  message: String!
  cv: DocumentType
  cover: DocumentType
  status: JobApplicationStatusEnum!
  createdAt: DateTime!
  updatedAt: DateTime!
  jobDefinition: JobDefinitionType!
}

type OrderShoppingCartAttributeType {
  label: String!
  externalId: String!
  isRequired: Boolean!
  isMultipleChoice: Boolean!
}

type OrderShoppingCartAttributesValuesType {
  label: String!
  externalId: String!
  attribute: OrderShoppingCartAttributeType!
}

type CouponType {
  id: ID!
  couponCode: String!
  target: TargetType!
  user: UserType
  redeemed: Boolean!
  discount: DiscountDtoType!
  from: DateTime
  to: DateTime
  createdAt: DateTime!
  updatedAt: DateTime!
}

type PurchaseType {
  id: ID!
  reference: String!
  externalId: String!
  notes: String
  status: PurchaseStatusEnum!
  installments: [InstallmentType!]!
  user: UserType!
  supplier: SupplierType!
  attachments: [DocumentType!]
  target: TargetType!
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum PurchaseStatusEnum {
  OPEN
  CANCELED
  CONFIRMED
  DELIVERED
}

type RentalNoteType {
  return: String
  delivery: String
}

type RentalRefType {
  id: ID!
  location: String
  description: String
  start: DateTime!
  end: DateTime!
  status: RentalStatusEnum
  note: RentalNoteType
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum RentalStatusEnum {
  RETURNED
  DELIVERED
  RETURNING
  DELIVERING
  READY_FOR_PICKUP
}

type CartProductType {
  barcode: BarcodeType
  quantity: Int!
  rent: RentalRefType
  taxValue: TaxValueType!
  price: ProductPriceType!
  priceCredit: PriceCreditType
}

type CartProductForTargetType {
  barcode: BarcodeForTargetType
  quantity: Int!
  taxValue: TaxValueType!
  price: ProductPriceType!
  priceCredit: PriceCreditType
}

type ShoppingCartsType {
  id: ID!
  user: UserType
  taxValue: ReduciblePriceType
  price: PriceFullType
  discount: DiscountDtoType
  target: TargetType
  createdAt: DateTime!
  updatedAt: DateTime!
  products: [CartProductForTargetType!]
}

type ShoppingCartsForTargetType {
  id: ID!
  user: UserType
  taxValue: ReduciblePriceType
  price: PriceFullType
  discount: DiscountDtoType
  target: TargetType
  createdAt: DateTime!
  updatedAt: DateTime!
  products: [CartProductForTargetType!]
}

type InvoiceType {
  id: ID
  number: String
  order: MarketPlaceOrderDtoType!
  month: Int
  year: Int
  sequence: Int
  status: InvoiceStatus
  target: TargetType
  description: String
  dueDate: DateTime
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum InvoiceStatus {
  DRAFT
  ISSUED
  CANCELED
}

type MarketplaceOrdersTypesCountType {
  PICKUP: Int!
  DELIVERY: Int!
  IN_HOUSE: Int!
  ORDER_AHEAD: Int!
}

type MarketplacePaymentMethodsCountType {
  CASH: Int!
  APP_COINS: Int!
}

type MarketplaceOrderByProductsMarketplaceOrderByStatusCountType {
  OPEN: Int!
  CANCELED: Int!
  CONFIRMED: Int!
  DELIVERED: Int!
}

type MarketplaceOrderByProductsMarketplaceOrderByPaymentStatusCountType {
  OPEN: Int!
  PAID: Int!
  CANCELED: Int!
}

type MarketPlaceOrdersCountType {
  total: Int!
  totalProducts: Int!
  orderTypes: MarketplaceOrdersTypesCountType!
  paymentMethods: MarketplacePaymentMethodsCountType!
  productsMarketplaceOrderByStatus: MarketplaceOrderByProductsMarketplaceOrderByStatusCountType!
  productsMarketplaceOrderByPaymentStatus: MarketplaceOrderByProductsMarketplaceOrderByPaymentStatusCountType!
}

type DateStatsType {
  current: String!
  previous: String!
  percentage: String!
}

type PurchasesStatusesFinanceDashboardDataType {
  OPEN: String
  ASSIGNED: String
  CANCELED: String
  CONFIRMED: String
  DELIVERED: String
  READY_FOR_PICKUP: String
}

type PaymentMethodsFinanceDashboardDataType {
  CASH: Int
  CHECK: Int
  APP_COINS: Int
  CREDIT_CARD: Int
  BANK_TRANSFER: Int
  MOBILE_PAYMENT: Int
  AUTOMATIC_DEBIT: Int
  BILL_OF_EXCHANGE: Int
}

type PaymentMethodsStatsType {
  current: PaymentMethodsFinanceDashboardDataType!
  previous: PaymentMethodsFinanceDashboardDataType!
  percentage: PaymentMethodsFinanceDashboardDataType!
}

type NewsletterType {
  id: ID!
  target: TargetType!
  email: String!
  user: UserType
  createdAt: DateTime!
  updatedAt: DateTime!
}

type LogisticTrackerType {
  status: LogisticStatus
  date: DateTime!
}

enum LogisticStatus {
  PLACED
  PACKED
  OUT_FOR_DELIVERY
  DELIVERED
}

type LogisticType {
  id: ID!
  identifier: String!
  company: CompanyType
  driver: UserType
  tracker: [LogisticTrackerType!]
  warehouse: WarehouseType
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ProjectMemberType {
  member: UserType
  role: ProjectRoleEnum
}

enum ProjectRoleEnum {
  LEAD
  MEMBER
}

type BoardCardsStatsType {
  total: Int!
  archived: Int!
}

type ProjectType {
  id: ID!
  name: String
  description: String
  media: MediaType
  privacy: ProjectPrivacyEnum
  tags: [String!]
  deadline: DateTime
  priority: ProjectPriorityEnum
  status: ProjectStatusEnum
  color: String
  picture: PictureType
  externalId: String
  members: [ProjectMemberType!]
  resources: [DocumentType!]
  attachments: [DocumentType!]
  target: TargetType
  boardCardsStats: BoardCardsStatsType
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum ProjectPrivacyEnum {
  PRIVATE
  PUBLIC
}

enum ProjectPriorityEnum {
  LOW
  NORMAL
  HIGH
  CRITICAL
}

enum ProjectStatusEnum {
  ACTIVE
  DELIVERED
  BLOCKED
  CANCELLED
}

type KeyValueType {
  key: String
  value: String
}

type InvoicingProductsType {
  id: ID!
  article: BarcodeType
  label: String
  description: String
  price: String
  total: String
  taxes: [ProductTaxesType!]
  quantity: Int
  discount: DiscountDtoType
  rent: RentalRefType
}

type InvoicingProductsBundleType {
  product: InvoicingProductsType
  text: String
  value: String
  rank: String!
  kind: ProductKindEnum!
}

enum ProductKindEnum {
  PRODUCT
  TEXT
  SECTION
  SEPARATOR
  SUBTOTAL
}

type InvoicingAddressType {
  billing: FullAddressType
  shipping: FullAddressType
}

type InvoicingPriceType {
  net: String
  gross: String
}

type TotalPriceType {
  net: String
  gross: String
}

type taxRankType {
  tax: TaxType
  rank: String
}

type RentalInvoicingType {
  id: ID!
  number: String!
  description: String
  status: GenericInvoicingStatusEnum
  address: InvoicingAddressType
  totalTax: String
  totalPrice: InvoicingPriceType
  toPay: String
  logistic: LogisticType
  project: ProjectType
  date: DateTime
}

enum GenericInvoicingStatusEnum {
  DRAFT
  OPEN
  ISSUED
  NEGOCIATION
  CONFIRMED
  DELIVERED
  CANCELED
}

type RentalInvoicingProductsType {
  id: ID!
  article: BarcodeType
  label: String
  description: String
  price: String
  total: String
  quantity: Int
  discount: DiscountDtoType
}

type RentalType {
  id: ID!
  location: String
  description: String
  start: DateTime!
  end: DateTime!
  status: RentalStatusEnum
  note: RentalNoteType
  createdAt: DateTime!
  updatedAt: DateTime!
  product: RentalInvoicingProductsType
  order: RentalInvoicingType
  invoice: RentalInvoicingType
  deliveryNote: RentalInvoicingType
}

type SaleCustomerType {
  customer: CompanyType
  details: [KeyValueType!]
}

type SaleDeliveryNoteOriginType {
  quotation: QuotationType
  order: SaleOrderType
}

type SaleDeliveryNoteType {
  id: ID!
  number: String!
  creator: UserType
  note: String
  description: String
  status: GenericInvoicingStatusEnum
  details: [KeyValueType!]
  products: [InvoicingProductsBundleType!]
  address: InvoicingAddressType
  totalTax: String
  totalPrice: InvoicingPriceType
  taxes: [taxRankType!]
  toPay: String
  installments: [InstallmentType!]
  logistic: LogisticType
  project: ProjectType
  date: DateTime
  target: TargetType!
  bank: BankDetailsType
  createdAt: DateTime!
  updatedAt: DateTime!
  customer: SaleCustomerType
  origin: SaleDeliveryNoteOriginType
  warehouse: WarehouseType
}

type QuotationConversionType {
  order: SaleOrderType
  deliveryNote: SaleDeliveryNoteType
  invoice: SaleInvoiceType
}

type QuotationType {
  id: ID!
  number: String!
  creator: UserType
  note: String
  description: String
  status: GenericInvoicingStatusEnum
  details: [KeyValueType!]
  products: [InvoicingProductsBundleType!]
  address: InvoicingAddressType
  totalTax: String
  totalPrice: InvoicingPriceType
  taxes: [taxRankType!]
  toPay: String
  installments: [InstallmentType!]
  logistic: LogisticType
  project: ProjectType
  date: DateTime
  target: TargetType!
  bank: BankDetailsType
  createdAt: DateTime!
  updatedAt: DateTime!
  customer: SaleCustomerType
  conversion: QuotationConversionType
}

type SaleInvoiceOriginType {
  quotation: QuotationType
  order: SaleOrderType
}

type SaleInvoiceType {
  id: ID!
  number: String!
  creator: UserType
  note: String
  description: String
  status: GenericInvoicingStatusEnum
  details: [KeyValueType!]
  products: [InvoicingProductsBundleType!]
  address: InvoicingAddressType
  totalTax: String
  totalPrice: InvoicingPriceType
  taxes: [taxRankType!]
  toPay: String
  installments: [InstallmentType!]
  logistic: LogisticType
  project: ProjectType
  date: DateTime
  target: TargetType!
  bank: BankDetailsType
  createdAt: DateTime!
  updatedAt: DateTime!
  customer: SaleCustomerType
  origin: SaleInvoiceOriginType
}

type SaleOrderConversionType {
  deliveryNote: SaleDeliveryNoteType
  invoice: SaleInvoiceType
}

type SaleOrderOriginType {
  quotation: QuotationType
}

type SaleOrderType {
  id: ID!
  number: String!
  creator: UserType
  note: String
  description: String
  status: GenericInvoicingStatusEnum
  details: [KeyValueType!]
  products: [InvoicingProductsBundleType!]
  address: InvoicingAddressType
  totalTax: String
  totalPrice: InvoicingPriceType
  taxes: [taxRankType!]
  toPay: String
  installments: [InstallmentType!]
  logistic: LogisticType
  project: ProjectType
  date: DateTime
  target: TargetType!
  bank: BankDetailsType
  createdAt: DateTime!
  updatedAt: DateTime!
  customer: SaleCustomerType
  conversion: SaleOrderConversionType
  origin: SaleOrderOriginType
}

type SaleIssueNoteType {
  id: ID!
  number: String!
  creator: UserType
  note: String
  description: String
  status: GenericInvoicingStatusEnum
  details: [KeyValueType!]
  products: [InvoicingProductsBundleType!]
  address: InvoicingAddressType
  totalTax: String
  totalPrice: InvoicingPriceType
  taxes: [taxRankType!]
  toPay: String
  installments: [InstallmentType!]
  logistic: LogisticType
  project: ProjectType
  date: DateTime
  target: TargetType!
  bank: BankDetailsType
  createdAt: DateTime!
  updatedAt: DateTime!
  customer: SaleCustomerType
}

type PurchaseSupplierType {
  supplier: CompanyType
  details: [KeyValueType!]
}

type PurchaseDeliveryNoteOriginType {
  order: PurchaseOrderType
}

type PurchaseDeliveryNoteType {
  id: ID!
  number: String!
  creator: UserType
  note: String
  description: String
  status: GenericInvoicingStatusEnum
  details: [KeyValueType!]
  products: [InvoicingProductsBundleType!]
  address: InvoicingAddressType
  totalTax: String
  totalPrice: InvoicingPriceType
  taxes: [taxRankType!]
  toPay: String
  installments: [InstallmentType!]
  logistic: LogisticType
  project: ProjectType
  date: DateTime
  target: TargetType!
  bank: BankDetailsType
  createdAt: DateTime!
  updatedAt: DateTime!
  supplier: PurchaseSupplierType
  origin: PurchaseDeliveryNoteOriginType
  warehouse: WarehouseType
}

type PurchaseInvoiceOriginType {
  order: PurchaseOrderType
}

type PurchaseInvoiceType {
  id: ID!
  number: String!
  creator: UserType
  note: String
  description: String
  status: GenericInvoicingStatusEnum
  details: [KeyValueType!]
  products: [InvoicingProductsBundleType!]
  address: InvoicingAddressType
  totalTax: String
  totalPrice: InvoicingPriceType
  taxes: [taxRankType!]
  toPay: String
  installments: [InstallmentType!]
  logistic: LogisticType
  project: ProjectType
  date: DateTime
  target: TargetType!
  bank: BankDetailsType
  createdAt: DateTime!
  updatedAt: DateTime!
  supplier: PurchaseSupplierType
  origin: PurchaseInvoiceOriginType
}

type PurchaseOrderConversionType {
  deliveryNote: PurchaseDeliveryNoteType
  invoice: PurchaseInvoiceType
}

type PurchaseOrderType {
  id: ID!
  number: String!
  creator: UserType
  note: String
  description: String
  status: GenericInvoicingStatusEnum
  details: [KeyValueType!]
  products: [InvoicingProductsBundleType!]
  address: InvoicingAddressType
  totalTax: String
  totalPrice: InvoicingPriceType
  taxes: [taxRankType!]
  toPay: String
  installments: [InstallmentType!]
  logistic: LogisticType
  project: ProjectType
  date: DateTime
  target: TargetType!
  bank: BankDetailsType
  createdAt: DateTime!
  updatedAt: DateTime!
  supplier: PurchaseSupplierType
  conversion: PurchaseOrderConversionType
}

type GoogleColorType {
  textColor: String!
  backgroundColor: String!
}

type GmailHeaderType {
  name: String
  value: String
}

type GmailMessagePartBodyType {
  size: Int
  data: String
}

type GmailMessagePartType {
  partId: String
  mimeType: String
  filename: String
  headers: [GmailHeaderType!]
  body: GmailMessagePartBodyType
  parts: [GmailMessagePartType!]
}

type GmailMessageType {
  id: String
  threadId: String
  labelIds: [String!]
  snippet: String
  historyId: String
  internalDate: String
  payload: GmailMessagePartType
  sizeEstimate: Int
  raw: String
}

type GmailDraftType {
  id: String
  message: GmailMessageType
}

type GmailThreadType {
  id: String
  snippet: String
  historyId: String
  messages: [GmailMessageType!]
}

type GoogleDriveAboutUserType {
  kind: String
  displayName: String
  photoLink: String
  me: Boolean
  permissionId: String
  emailAddress: String
}

type GoogleDriveAboutStorageQuotaType {
  limit: String
  usage: String
  usageInDrive: String
  usageInDriveTrash: String
}

type GoogleDriveAboutTeamDriveThemesType {
  id: String
  backgroundImageLink: String
  colorRgb: String
}

type GoogleDriveFileCapabilitiesType {
  canAddChildren: Boolean
  canAddFolderFromAnotherDrive: Boolean
  canAddMyDriveParent: Boolean
  canChangeCopyRequiresWriterPermission: Boolean
  canChangeSecurityUpdateEnabled: Boolean
  canChangeViewersCanCopyContent: Boolean
  canComment: Boolean
  canCopy: Boolean
  canDelete: Boolean
  canDeleteChildren: Boolean
  canDownload: Boolean
  canEdit: Boolean
  canListChildren: Boolean
  canModifyContent: Boolean
  canModifyContentRestriction: Boolean
  canMoveChildrenOutOfTeamDrive: Boolean
  canMoveChildrenOutOfDrive: Boolean
  canMoveChildrenWithinTeamDrive: Boolean
  canMoveChildrenWithinDrive: Boolean
  canMoveItemIntoTeamDrive: Boolean
  canMoveItemOutOfTeamDrive: Boolean
  canMoveItemOutOfDrive: Boolean
  canMoveItemWithinTeamDrive: Boolean
  canMoveItemWithinDrive: Boolean
  canMoveTeamDriveItem: Boolean
  canReadRevisions: Boolean
  canReadTeamDrive: Boolean
  canReadDrive: Boolean
  canRemoveChildren: Boolean
  canRemoveMyDriveParent: Boolean
  canRename: Boolean
  canShare: Boolean
  canTrash: Boolean
  canTrashChildren: Boolean
  canUntrash: Boolean
}

type GoogleDriveTeamDrivePermissionDetailsType {
  teamDrivePermissionType: String
  role: String
  inheritedFrom: String
  inherited: Boolean
}

type GoogleDriveThumbnailType {
  image: String
  mimeType: String
}

type GoogleDriveContentHintsType {
  thumbnail: GoogleDriveThumbnailType
  indexableText: String
}

type GoogleDriveLocationType {
  latitude: Float
  longitude: Float
  altitude: Float
}

type GoogleDriveShortcutDetailsType {
  targetId: String
  targetMimeType: String
  targetResourceKey: String
}

type GoogleDriveLinkShareMetadataType {
  securityUpdateEligible: Boolean
  securityUpdateEnabled: Boolean
}

type GoogleDriveContentRestrictionsType {
  readOnly: Boolean
  reason: String
  restrictingUser: GoogleDriveAboutUserType
  restrictionTime: String
  type: String
}

type GoogleDriveImageMediaMetaDataType {
  width: Int
  height: Int
  rotation: Int
  location: GoogleDriveLocationType
  time: String
  cameraMake: String
  cameraModel: String
  exposureTime: Float
  aperture: Float
  flashUsed: Boolean
  focalLength: Float
  isoSpeed: Int
  meteringMode: String
  sensor: String
  exposureMode: String
  colorSpace: String
  whiteBalance: String
  exposureBias: Float
  maxApertureValue: Float
  subjectDistance: Int
  lens: String
}

type GoogleDriveFilePermissionsType {
  kind: String
  id: String
  type: String
  emailAddress: String
  domain: String
  role: String
  view: String
  allowFileDiscovery: Boolean
  displayName: String
  photoLink: String
  expirationTime: String
  teamDrivePermissionDetails: [GoogleDriveTeamDrivePermissionDetailsType!]
  permissionDetails: [GoogleDriveTeamDrivePermissionDetailsType!]
  deleted: Boolean
}

type GoogleDriveFileResourceType {
  kind: String
  id: String
  name: String
  mimeType: String
  description: String
  starred: Boolean
  trashed: Boolean
  explicitlyTrashed: Boolean
  trashingUser: GoogleDriveAboutUserType
  trashedTime: String
  spaces: [String!]
  webContentLink: String
  webViewLink: String
  iconLink: String
  hasThumbnail: Boolean
  thumbnailLink: String
  viewedByMe: Boolean
  viewedByMeTime: String
  createdTime: String
  modifiedTime: String
  modifiedByMeTime: String
  modifiedByMe: Boolean
  sharedWithMeTime: String
  sharingUser: GoogleDriveAboutUserType
  owners: [GoogleDriveAboutUserType!]
  teamDriveId: String
  driveId: String
  lastModifyingUser: GoogleDriveAboutUserType
  shared: Boolean
  ownedByMe: Boolean
  capabilities: GoogleDriveFileCapabilitiesType
  viewersCanCopyContent: Boolean
  copyRequiresWriterPermission: Boolean
  writersCanShare: Boolean
  permissions: [GoogleDriveFilePermissionsType!]
  permissionIds: [String!]
  hasAugmentedPermissions: Boolean
  folderColorRgb: String
  originalFilename: String
  fullFileExtension: String
  fileExtension: String
  md5Checksum: String
  headRevisionId: String
  contentHints: GoogleDriveContentHintsType
  imageMediaMetadata: GoogleDriveImageMediaMetaDataType
  isAppAuthorized: Boolean
  shortcutDetails: GoogleDriveShortcutDetailsType
  contentRestrictions: [GoogleDriveContentRestrictionsType!]
  resourceKey: String
  linkShareMetadata: GoogleDriveLinkShareMetadataType
}

type GoogleDriveBackgroundImageFileType {
  id: String
  xCoordinate: Float
  yCoordinate: Float
  width: Float
}

type GoogleDriveRestrictionsType {
  adminManagedRestrictions: Boolean
  copyRequiresWriterPermission: Boolean
  domainUsersOnly: Boolean
  driveMembersOnly: Boolean
}

type GoogleDriveTeamDriveResourceType {
  kind: String
  id: String
  name: String
  themeId: String
  colorRgb: String
  backgroundImageFile: GoogleDriveBackgroundImageFileType
  capabilities: GoogleDriveFileCapabilitiesType
  createdTime: String
  hidden: Boolean
  restrictions: GoogleDriveRestrictionsType
}

type GoogleDriveAboutChangesResourceType {
  kind: String
  type: String
  changeType: String
  time: String
  removed: Boolean
  fileId: String
  file: GoogleDriveFileResourceType
  teamDriveId: String
  driveId: String
  teamDrive: GoogleDriveTeamDriveResourceType
  drive: GoogleDriveTeamDriveResourceType
}

type GoogleCalendarDefaultReminderType {
  method: String!
  minutes: Int
}

type GoogleCalendarNotificationSettingsType {
  notifications: [GoogleCalendarNotificationSettingsNotificationType!]!
}

type GoogleCalendarNotificationSettingsNotificationType {
  type: String!
  method: String!
}

type GoogleCalendarConferencePropertiesType {
  allowedConferenceSolutionTypes: [String!]!
}

type GoogleCalendarListResourceType {
  kind: String!
  etag: String
  id: String
  summary: String
  description: String
  location: String
  timeZone: String
  summaryOverride: String
  colorId: String
  backgroundColor: String
  foregroundColor: String
  hidden: Boolean
  selected: Boolean
  accessRole: String
  defaultReminders: [GoogleCalendarDefaultReminderType!]
  notificationSettings: GoogleCalendarNotificationSettingsType
  primary: Boolean
  deleted: Boolean
  conferenceProperties: GoogleCalendarConferencePropertiesType
}

type GoogleCalendarBackForType {
  background: String!
  foreground: String
}

type GoogleCalendarEventCreatorType {
  id: String
  email: String
  displayName: String
  self: Boolean
}

type GoogleCalendarEventStartEndType {
  date: String
  dateTime: String
  timeZone: String
}

type GoogleCalendarEventAttendeeType {
  id: String
  email: String
  displayName: String
  organizer: Boolean
  self: Boolean
  resource: Boolean
  optional: Boolean
  responseStatus: String
  comment: String
  additionalGuests: Int
}

type GoogleCalendarEventConferenceDataCreateRequestSolutionKeyType {
  type: String
}

type GoogleCalendarEventConferenceDataCreateRequesStatusType {
  statusCode: String
}

type GoogleCalendarEventConferenceDataCreateRequestType {
  requestId: String
  conferenceSolutionKey: GoogleCalendarEventConferenceDataCreateRequestSolutionKeyType
  status: GoogleCalendarEventConferenceDataCreateRequesStatusType
}

type GoogleCalendarEventConferenceDataEntryPointsType {
  entryPointType: String
  uri: String
  label: String
  pin: String
  accessCode: String
  meetingCode: String
  passcode: String
  password: String
}

type GoogleCalendarEventConferenceDataConferenceSolutionKeyType {
  type: String
}

type GoogleCalendarEventConferenceDataConferenceSolutionType {
  key: GoogleCalendarEventConferenceDataConferenceSolutionKeyType
  name: String
  iconUri: String
}

type GoogleCalendarEventConferenceDataType {
  createRequest: GoogleCalendarEventConferenceDataCreateRequestType
  entryPoints: [GoogleCalendarEventConferenceDataEntryPointsType!]
  conferenceSolution: GoogleCalendarEventConferenceDataConferenceSolutionType
  conferenceId: String
  signature: String
  notes: String
}

type GoogleCalendarEventGadgetType {
  type: String
  title: String
  link: String
  iconLink: String
  width: Int
  height: Int
  display: String
}

type GoogleCalendarEventReminderOverridesType {
  method: String
  minutes: Float
}

type GoogleCalendarEventReminderType {
  useDefault: Boolean
  overrides: GoogleCalendarEventReminderOverridesType
}

type GoogleCalendarEventSourceType {
  url: String
  title: String
}

type GoogleCalendarEventAttachmentType {
  fileUrl: String
  title: String
  mimeType: String
  iconLink: String
  fileId: String
}

type GoogleCalendarEventType {
  kind: String
  etag: String
  id: String
  status: String
  htmlLink: String
  created: String
  updated: String
  summary: String
  description: String
  location: String
  colorId: String
  creator: GoogleCalendarEventCreatorType
  organizer: GoogleCalendarEventCreatorType
  start: GoogleCalendarEventStartEndType
  end: GoogleCalendarEventStartEndType
  endTimeUnspecified: Boolean
  recurrence: [String!]
  recurringEventId: String
  originalStartTime: GoogleCalendarEventStartEndType
  transparency: String
  visibility: String
  iCalUID: String
  sequence: Int
  attendees: [GoogleCalendarEventAttendeeType!]
  attendeesOmitted: Boolean
  hangoutLink: String
  conferenceData: GoogleCalendarEventConferenceDataType
  gadget: GoogleCalendarEventGadgetType
  anyoneCanAddSelf: Boolean
  guestsCanInviteOthers: Boolean
  guestsCanModify: Boolean
  guestsCanSeeOtherGuests: Boolean
  privateCopy: Boolean
  locked: Boolean
  reminders: GoogleCalendarEventReminderType
  source: GoogleCalendarEventSourceType
  attachments: [GoogleCalendarEventAttachmentType!]
  eventType: String
}

type GoogleCalendarSettingsType {
  kind: String
  etag: String
  id: String
  value: String
}

type SmsIntegrationType {
  messageId: String!
  statusMobile: String!
  statusMsg: String!
  statusCode: String!
}

type SmsLogType {
  id: ID!
  phone: IPhoneType
  validationNumber: Int
  createdAt: DateTime!
  updatedAt: DateTime!
}

type SEOAuditDataType {
  url: String
  title: String
  isLoaded: Boolean
  isGoogleAnalyticsObject: Boolean
  isGoogleAnalyticsFunc: Boolean
  isCharacterEncode: Boolean
  isMetaDescription: Boolean
  metaDescription: String
  isMetaDescriptionEnoughLong: Boolean
  isDoctype: Boolean
  isTitle: Boolean
  isTitleEnoughLong: Boolean
  isH1: Boolean
  h1: String
  isH1OnlyOne: Boolean
  isH2: Boolean
  linksCount: Int
  isTooEnoughLinks: Boolean
  internalNoFollowLinks: [String!]
  internalNoFollowLinksCount: Int
  notOptimizedImages: [String!]
  notOptimizedImagesCount: Int
  wordsCount: Int
  isContentEnoughLong: Boolean
  isViewport: Boolean
  isAmp: Boolean
  isNotIframe: Boolean
  pageIsBlocked: Boolean
  robotsFileExists: Boolean
  faviconExists: Boolean
  brokenLinksCount: Int
  brokenLinks: [String!]
  externalBrokenLinksCount: Int
  externalBrokenLinks: [String!]
  brokenImages: [String!]
  brokenImagesCount: Int
}

type InstagramProfileAuditDataLatestType {
  id: String
  type: String
  shortCode: String
  caption: String
  hashtags: [String!]
  mentions: [String!]
  url: String
  commentsCount: Float
  firstComment: String
  latestComments: [String!]
  dimensionsHeight: Float
  dimensionsWidth: Float
  displayUrl: String
  images: [String!]
  alt: String
  likesCount: Float
  timestamp: DateTime
  childPosts: [String!]
  ownerUsername: String
  ownerId: String
}

type InstagramProfileAuditDataIVGType {
  type: String
  shortCode: String
  title: String
  caption: String
  commentsCount: Float
  commentsDisabled: Boolean
  dimensionsHeight: Float
  dimensionsWidth: Float
  displayUrl: String
  likesCount: Float
  videoDuration: Float
  videoViewCount: Float
}

type InstagramProfileAuditDataType {
  id: String
  username: String
  fullName: String
  biography: String
  externalUrl: String
  externalUrlShimmed: String
  followersCount: Float
  followsCount: Float
  hasChannel: Boolean
  highlightReelCount: Float
  isBusinessAccount: Boolean
  joinedRecently: Boolean
  businessCategoryName: String
  private: Boolean
  verified: Boolean
  profilePicUrl: String
  profilePicUrlHD: String
  facebookPage: String
  igtvVideoCount: Float
  relatedProfiles: [String!]
  latestIgtvVideos: [InstagramProfileAuditDataIVGType!]
  postsCount: Float
  latestPosts: [InstagramProfileAuditDataLatestType!]
}

type FacebookProfileAuditMenuImagesPhotosOwnerType {
  id: String
  user_id: String
  additional_profile_has_taggable_products: Boolean
}

type FacebookProfileAuditMenuImagesPhotosImageType {
  uri: String
  width: Float
  height: Float
}

type FacebookProfileAuditMenuImagesPhotosType {
  id: String
  timestamp: Float
  ocrText: String
  image: FacebookProfileAuditMenuImagesPhotosImageType
  likes: Float
  isPlayable: Boolean
  owner: FacebookProfileAuditMenuImagesPhotosOwnerType
}

type FacebookProfileAuditMenuImagesType {
  id: String
  menu_image_title: String
  menu_photo: FacebookProfileAuditMenuImagesPhotosType
}

type FacebookProfileAuditMenuType {
  id: String
  share_page_menu_link: String
  structured_menu_program: String
  images: [FacebookProfileAuditMenuImagesType!]
}

type FacebookProfileAuditDeliverySettingsType {
  delivery_details: String
  id: String
}

type FacebookProfileAuditReviewUserType {
  id: String
  name: String
  profileUrl: String
  profilePic: String
}

type FacebookProfileAuditReviewType {
  id: String
  legacyId: String
  user: FacebookProfileAuditReviewUserType
  date: String
  url: String
  text: String
  likesCount: Float
  commentsCount: Float
}

type FacebookProfilePostsStatsType {
  likes: Float
  comments: Float
  shares: Float
}

type FacebookProfilePostsCommentsType {
  count: Float
}

type FacebookProfilePostsType {
  postDate: DateTime
  postText: String
  postsImages: [String!]
  postLinks: [String!]
  postUrl: String
  postStats: FacebookProfilePostsStatsType
  postComments: FacebookProfilePostsCommentsType
  postId: String
  timestamp: Float
  alt: String
}

type FacebookProfileAuditDataType {
  categories: [String!]
  info: [String!]
  likes: Float
  messenger: String
  posts: [FacebookProfilePostsType!]
  priceRange: String
  title: String
  pageUrl: String
  address: String
  payment: String
  pageId: String
  pageName: String
  phone: String
  email: String
  website: String
  services: String
  rating: String
  wifi: String
  reviews: [FacebookProfileAuditReviewType!]
  delivery_settings: FacebookProfileAuditDeliverySettingsType
  formatted_cuisines: String
  delivery_options: String
  menu: FacebookProfileAuditMenuType
  is_delegate_page_with_linked_profile: Boolean
  name: String
  impressum: [String!]
  instagram: String
  products: [String!]
  transit: String
  twitter: String
  youtube: String
  mission: [String!]
  overview: [String!]
  checkins: String
  verified: Boolean
}

type GoogleMapsAuditDataOrderType {
  name: String
  url: String
}

type GoogleMapsAuditDataReviewsType {
  oneStar: Float
  twoStar: Float
  threeStar: Float
  fourStar: Float
  fiveStar: Float
}

type GoogleMapsAuditDataLocationType {
  lat: Float
  lng: Float
}

type GoogleMapsAuditDataType {
  title: String
  subTitle: String
  price: String
  menu: String
  categoryName: String
  address: String
  locatedIn: String
  neighborhood: String
  street: String
  city: String
  postalCode: String
  state: String
  countryCode: String
  plusCode: String
  website: String
  phone: String
  temporarilyClosed: Boolean
  location: GoogleMapsAuditDataLocationType
  permanentlyClosed: Boolean
  totalScore: String
  isAdvertisement: Boolean
  rank: Float
  placeId: String
  categories: [String!]
  cid: String
  url: String
  searchPageUrl: String
  searchString: String
  scrapedAt: DateTime
  reviewsCount: Float
  reviewsDistribution: GoogleMapsAuditDataReviewsType
  reviews: [String!]
  orderBy: GoogleMapsAuditDataOrderType
}

type GoogleSearchAuditDataDebugType {
  requestId: String
  url: String
  method: String
  retryCount: Float
  errorMessages: [String!]
  statusCode: Float
  durationSecs: Float
}

type GoogleSearchAuditDataSearchQueryType {
  term: String
  device: String
  page: Float
  type: String
  domain: String
  countryCode: String
  languageCode: String
  locationUule: String
  resultsPerPage: String
}

type GoogleSearchAuditDataRelatedQueriesType {
  title: String
  url: String
}

type GoogleSearchAuditDataResultsProductType {
  price: String
  rating: Float
  numberOfReviews: Float
}

type GoogleSearchAuditDataSiteLinksType {
  title: String
  description: String
}

type GoogleSearchAuditDataResultsType {
  title: String
  url: String
  displayedUrl: String
  description: String
  emphasizedKeywords: [String!]
  siteLinks: [GoogleSearchAuditDataSiteLinksType!]
  productInfo: GoogleSearchAuditDataResultsProductType
}

type GoogleSearchAuditDataCustomDataType {
  pageTitle: String
}

type GoogleSearchAuditDataType {
  debug: GoogleSearchAuditDataDebugType
  error: Boolean
  searchQuery: GoogleSearchAuditDataSearchQueryType
  url: String
  hasNextPage: Boolean
  serpProviderCode: String
  resultsTotal: Float
  relatedQueries: [GoogleSearchAuditDataRelatedQueriesType!]
  paidResults: [GoogleSearchAuditDataResultsType!]
  paidProducts: [GoogleSearchAuditDataResultsType!]
  organicResults: [GoogleSearchAuditDataResultsType!]
  customData: GoogleSearchAuditDataCustomDataType
  htmlSnapshotUrl: String
}

type GoogleAnalyticsEventType {
  event: GARecommendedEventsEnum!
  active: Boolean!
}

enum GARecommendedEventsEnum {
  LOGIN
  SIGN_UP
  SEARCH
  SHARE
  EARN_VIRTUAL_CURRENCY
  SPEND_VIRTUAL_CURRENCY
  ADD_PAYMENT_INFO
  ADD_SHIPPING_INFO
  ADD_TO_CART
  ADD_TO_WISHLIST
  BEGIN_CHECKOUT
  GENERATE_LEAD
  PURCHASE
  REFUND
  REMOVE_FROM_CART
  SELECT_ITEM
  SELECT_PROMOTION
  VIEW_CART
  VIEW_ITEM
  VIEW_PROMOTION
}

type FBPixelEventType {
  event: PixelRecommendedEventsEnum!
  active: Boolean!
}

enum PixelRecommendedEventsEnum {
  ADD_PAYMENT_INFO
  ADD_TO_CART
  ADD_TO_WISHLIST
  COMPLETE_REGISTRATION
  CONTACT
  FIND_LOCATION
  INITIATE_CHECKOUT
  LEAD
  PURCHASE
  SCHEDULE
  SEARCH
  START_TRIAL
  SUBSCRIBE
  VIEW_CONTENT
}

type FBCatalogSyncAttributesType {
  active: Boolean!
  color: Boolean!
  gender: Boolean!
  size: Boolean!
  ageGroup: Boolean!
  material: Boolean!
  pattern: Boolean!
}

type FBCatalogSyncShippingType {
  active: Boolean!
  country: CountryType
  service: String
  price: String
}

type FigamyIntegrationAuthType {
  publicKey: String
  secretKey: String
}

type FigamyIntegrationAuthenticationLoginType {
  active: Boolean!
}

type FigamyIntegrationAuthenticationType {
  active: Boolean!
  appAuth: FigamyIntegrationAuthType
  figamyAuth: FigamyIntegrationAuthType
  login: FigamyIntegrationAuthenticationLoginType
}

type FigamyIntegrationWalletReputationType {
  active: Boolean!
  inactivityCycle: Boolean!
  lossAmount: Boolean!
  perks: Boolean!
}

type FigamyIntegrationWalletType {
  active: Boolean!
  quantitative: FigamyIntegrationAuthenticationLoginType
  qualitative: FigamyIntegrationAuthenticationLoginType
  reputation: FigamyIntegrationWalletReputationType
}

type FigamyIntegrationCatalogType {
  active: Boolean!
  auth: FigamyIntegrationAuthType
  syncTime: RecurrenceType
  sell: Boolean!
  sale: Boolean!
  shipping: Boolean!
}

type FigamyIntegrationDealsType {
  active: Boolean!
  monthlyAmount: String
  selfManaging: Boolean!
}

type FigamyIntegratioConverterType {
  active: Boolean!
  rate: String
}

type FigamyIntegratioMarketplaceType {
  active: Boolean
  paymentCycle: RecurrenceType
  comission: String
}

type TopChartCategoryItemType {
  key: String!
  value: String!
  cron: Boolean!
}

type TopChartGenreType {
  id: ID!
  platform: ChartPlatformEnum!
  category: TopChartCategoryItemType!
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum ChartPlatformEnum {
  IPHONE
  IPAD
  IOS
  ANDROID
  AMAZON
}

type AppFollowTopChartType {
  id: ID!
  date: DateTime
  country: String!
  genre: TopChartGenreType
  leaderboard: [TopChartLeaderboardType!]
  createdAt: DateTime!
  updatedAt: DateTime!
}

type TopChartLeaderboardType {
  pos_diff: Float
  device: String
  genre_id: String
  icon: String
  country: String
  rating_avg: String
  feed_type: String
  price: String
  ext_id: String
  pos_curr: Float
  pos: Float
  url: String
  artist_name: String
  title: String
}

type AppTweakTopChartType {
  id: ID!
  date: DateTime
  country: CountryType!
  appType: ChartAppTypeEnum!
  genre: TopChartGenreType
  leaderboard: [AppTweakTopChartLeaderboardType!]
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum ChartAppTypeEnum {
  FREE
  PAID
  GROSSING
}

type AppTweakTopChartLeaderboardType {
  id: String
  title: String
  icon: String
  developer: String
  price: String
  genres: [String!]
  devices: [String!]
  slug: String
  rating: Float
  in_apps: Boolean
  ratings_count: Int
  power: Float
}

type ErpIntegrationEventType {
  event: ErpElementsEnum!
  active: Boolean!
}

enum ErpElementsEnum {
  PRODUCTS
  SERVICES
  EQUIPMENTS
  CUSTOMERS
  CONTACTS
  SUPPLIERS
  QUOTATIONS
  SALE_ORDERS
  SALE_INVOICES
  SALE_DELIVERY_NOTES
  SALE_ISSUE_NOTES
  PURCHASE_INVOICES
  PURCHASE_DELIVERY_NOTES
  PURCHASE_ORDERS
}

type WidgetIntegrationActionsType {
  definition: QuestPredefinedActionsEnum
  recurrence: QuestActionsRecurrenceType
  remuneration: RemunerationDtoType
}

type WidgetIntegrationContentType {
  profile: Boolean
  notification: Boolean
  quantitative: Boolean
  qualitative: Boolean
  chat: Boolean
  campaigns: Boolean
  pages: [LandingPageTypeEnum!]
}

type QuestsCountType {
  total: Int!
  DRAFT: Int!
  ONGOING: Int!
  FINISHED: Int!
}

type QuestActionsCountType {
  total: Int!
  EXPIRED: Int!
  PERFORMED: Int!
  IN_PROGRESS: Int!
}

type QuestActivitiesCountType {
  total: Int!
}

type QuestTypeType {
  id: ID!
  title: String
  description: String
  icon: String
  media: MediaType
  activityTypes: [ActivityTypeType!]
  maxActivities: Int
  rewardPoints: String
  minCoins: String
  fees: String
  score: Boolean
  profile: Boolean
  admin: Boolean
  transition: Boolean
  condition: Boolean
  enable: Boolean
  target: TargetType
  createdAt: DateTime!
  updatedAt: DateTime!
}

type OwnerDtoType {
  pos: PointOfSaleType
  user: UserType
  wholesaler: WholesalerType
  manufacturer: ManufacturerType
}

type PocketWithoutTargetType {
  id: ID!
  usage: PocketUsageType!
  pocketType: PocketTypeEnum!
  amount: String
  challenge: ChallengeType
}

enum PocketUsageType {
  MAIN
  BONUS
}

type PocketType {
  id: ID!
  usage: PocketUsageType!
  pocketType: PocketTypeEnum!
  amount: String
  challenge: ChallengeType
  target: TargetType
}

type PocketWithReputationsType {
  id: ID!
  usage: PocketUsageType!
  pocketType: PocketTypeEnum!
  amount: String
  challenge: ChallengeType
  target: TargetType
  reputationLevels: [ReputationType!]
}

type WalletDtoType {
  id: ID!
  owner: OwnerDtoType
  createdAt: DateTime!
  updatedAt: DateTime!
  pockets: [PocketType!]
}

type IsWalletAndCardInititalizedDtoType {
  isUserCardCreated: Boolean!
  isQuantitativeWalletCreated: Boolean!
}

type WalletOwnerHasEnoughBalanceType {
  hasEnoughBalance: Boolean!
}

type OwnerLessWalletOnePocketDtoType {
  id: ID!
  pocket: PocketType
  createdAt: DateTime!
  updatedAt: DateTime!
}

type POSWithWalletType {
  id: ID!
  name: String
  title: String
  subtitle: String
  description: String
  tags: [String!]
  brandColor: String
  reference: String
  published: Boolean
  picture: PictureType
  outsidePictures: [PictureType!]
  insidePictures: [PictureType!]
  openingHours: OpeningHoursType
  specialOffers: [SpecialOfferType!]
  email: [String!]
  contactEmails: [String!]
  currency: Currency
  languages: [LanguageType!]
  phone: [String!]
  website: String
  chatContact: [SocialValueType!]
  socialMedia: [SocialValueType!]
  averageCustomers: Float
  turnover: String
  locations: [FullAddressType!]
  isFollowed: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
  posCategory: [POSCategoryType!]
  company: CompanyType
  services: [POSServicesType!]
  paymentMethods: [PaymentType!]
  loyaltyPrograms: [POSLoyaltyType!]
  wallet: OwnerLessWalletOnePocketDtoType
}

type POSWithWalletPaginateType {
  count: Int
  isLast: Boolean
  objects: [POSWithWalletType!]!
}

type WalletOnePocketDtoType {
  id: ID!
  pocket: PocketType
  createdAt: DateTime!
  updatedAt: DateTime!
  owner: OwnerDtoType
}

type WalletOnePocketWithoutTargetDtoType {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  owner: OwnerDtoType
  pocket: PocketWithoutTargetType
}

type WalletPaginateType {
  count: Int
  isLast: Boolean
  objects: [WalletDtoType!]!
}

type WalletLeaderboardType {
  user: UserType!
  rank: Int!
  amount: String!
  reputationLevel: ReputationType
}

type IsFollowedType {
  isFollowed: Boolean!
}

type FollowerType {
  id: ID!
  target: TargetType
  user: UserType
  createdAt: DateTime!
  updatedAt: DateTime!
}

type PointOfSaleWithFollowShipStatusType {
  id: ID!
  name: String
  title: String
  subtitle: String
  description: String
  tags: [String!]
  brandColor: String
  reference: String
  published: Boolean
  picture: PictureType
  outsidePictures: [PictureType!]
  insidePictures: [PictureType!]
  openingHours: OpeningHoursType
  specialOffers: [SpecialOfferType!]
  email: [String!]
  contactEmails: [String!]
  currency: Currency
  languages: [LanguageType!]
  phone: [String!]
  website: String
  chatContact: [SocialValueType!]
  socialMedia: [SocialValueType!]
  averageCustomers: Float
  turnover: String
  locations: [FullAddressType!]
  isFollowed: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
  posCategory: [POSCategoryType!]
  company: CompanyType
  services: [POSServicesType!]
  paymentMethods: [PaymentType!]
  loyaltyPrograms: [POSLoyaltyType!]
}

type FollowerPaginateType {
  count: Int
  isLast: Boolean
  objects: [FollowerType!]!
}

type PointOfSaleWithFollowShipStatusPaginateType {
  count: Int
  isLast: Boolean
  objects: [PointOfSaleWithFollowShipStatusType!]!
}

type EffectiveDateType {
  end: String!
  start: String!
}

type LeaderboardBaseType {
  user: UserType
  target: TargetType
  credit: String!
  rank: Int!
  rankDifference: Int!
  effectiveDate: EffectiveDateType!
  cycle: LeaderboardCycleEnum!
  currentReputationLevel: ReputationWithoutTargetType
  nextReputationLevel: ReputationWithoutTargetType
}

enum LeaderboardCycleEnum {
  OVERALL
  DAILY
  WEEKLY
  MONTHLY
}

type LeaderboardType {
  user: UserType
  target: TargetType
  credit: String!
  rank: Int!
  rankDifference: Int!
  effectiveDate: EffectiveDateType!
  cycle: LeaderboardCycleEnum!
  currentReputationLevel: ReputationWithoutTargetType
  nextReputationLevel: ReputationWithoutTargetType
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type LeaderboardPaginatedType {
  count: Int
  isLast: Boolean
  objects: [LeaderboardType!]!
}

type EffectiveDatePaginatedType {
  count: Int
  isLast: Boolean
  objects: [EffectiveDateType!]!
}

type LeaderboardBasePaginatedType {
  count: Int
  isLast: Boolean
  objects: [LeaderboardBaseType!]!
}

type IsUserSubscribedToTargetType {
  isSubscribed: Boolean!
  status: SubscriptionStatus
}

enum SubscriptionStatus {
  PENDING
  APPROVED
  REJECTED
}

type SubscribersFullType {
  id: ID!
  target: TargetType
  status: SubscriptionStatus
  createdAt: DateTime!
  updatedAt: DateTime!
  user: UserType
}

type SubscribersFullWithReputationType {
  id: ID!
  target: TargetType
  status: SubscriptionStatus
  createdAt: DateTime!
  updatedAt: DateTime!
  user: UserType
  wallet: WalletOnePocketWithoutTargetDtoType
  currentReputationLevel: ReputationWithoutTargetType
  nextReputationLevel: ReputationWithoutTargetType
}

type StatsType {
  numberOfProducts: Int!
  numberOfFollowers: Int!
  numberOfSubscribers: Int!
}

type SubscribersWithReputationsPaginateType {
  count: Int
  isLast: Boolean
  objects: [SubscribersFullWithReputationType!]!
}

type ProductWalletTopupType {
  name: String
  price: String
  tax: String
}

type WalletTopupFullType {
  id: ID
  pos: PointOfSaleType
  createdAt: DateTime!
  updatedAt: DateTime!
  executor: UserType
}

type OnsiteConverterType {
  id: ID!
  target: TargetType!
  remunerations: [RemunerationWithReputationDtoType!]!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type APICredentialsType {
  publicKey: String
  secretKey: String
}

type LoyaltySettingsOnsiteConverterIntgType {
  active: Boolean
  credentials: APICredentialsType
}

type LoyaltySettingsOnsiteConverterType {
  active: Boolean!
  onsiteConverter: OnsiteConverterType
  cashregisterIntegration: LoyaltySettingsOnsiteConverterIntgType
}

type LoyaltySettingsWalletType {
  active: Boolean!
  picture: PictureType
}

type LoyaltySettingsWalletCardType {
  digital: Boolean!
  physical: Boolean!
  validity: Int!
}

type LoyaltySettingsWalletLeaderboardType {
  active: Boolean!
  overall: Boolean!
  monthly: Boolean!
  weekly: Boolean!
}

type LoyaltySettingsWalletSubscribersType {
  verification: Boolean!
}

type LoyaltySettingsType {
  id: ID!
  qualitative: LoyaltySettingsWalletType
  quantitative: LoyaltySettingsWalletType
  onsiteConverter: LoyaltySettingsOnsiteConverterType
  loyaltyCard: LoyaltySettingsWalletCardType
  leaderboard: LoyaltySettingsWalletLeaderboardType
  subscribers: LoyaltySettingsWalletSubscribersType
  target: TargetType
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ChallengeActionType {
  id: ID!
  label: String
  enable: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

type LabelType {
  id: ID!
  name: String!
  category: LabelTypeEnum
  icon: String
  color: String
  target: TargetType!
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum LabelTypeEnum {
  NOTES
  SCRUM
}

type NotesTaskType {
  title: String!
  done: Boolean
}

type BoardCardProcedureType {
  title: String
  task: BoardCardProcedureEnum
  time: DateTime
}

enum BoardCardProcedureEnum {
  MEETING
  CALL
  CONFERENCE
  DEMO
  CHAT
}

type BoardCardTasksType {
  task: String
  done: Boolean
}

type TasksStatsType {
  total: Int!
  done: Int!
}

type BoardCardForListType {
  id: ID!
  title: String!
  description: String
  dueDate: DateTime
  archived: Boolean
  priority: BoardCardPriorityEnum
  tags: [String!]
  pictures: [PictureType!]
  barcode: BarcodeType
  project: ProjectType
  tasks: [BoardCardTasksType!]
  labels: [LabelType!]
  rank: Int
  assignedTo: [UserType!]
  budget: String
  customer: CompanyType
  procedure: [BoardCardProcedureType!]
  attachments: [DocumentType!]
  tasksStats: TasksStatsType
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum BoardCardPriorityEnum {
  LOW
  NORMAL
  HIGH
  CRITICAL
}

type BoardCardType {
  id: ID!
  title: String!
  description: String
  dueDate: DateTime
  archived: Boolean
  priority: BoardCardPriorityEnum
  tags: [String!]
  pictures: [PictureType!]
  barcode: BarcodeType
  project: ProjectType
  tasks: [BoardCardTasksType!]
  labels: [LabelType!]
  rank: Int
  assignedTo: [UserType!]
  budget: String
  customer: CompanyType
  procedure: [BoardCardProcedureType!]
  attachments: [DocumentType!]
  tasksStats: TasksStatsType
  createdAt: DateTime!
  updatedAt: DateTime!
  boardList: BoardListType!
}

type BoardListType {
  id: ID!
  name: String!
  rank: Int
  theme: String
  identifier: MaintenanceBoardListEnum
  board: BoardType!
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum MaintenanceBoardListEnum {
  NEW_REQUEST
  IN_PROGRESS
  REPLACED
  SCRAP
}

type ListWithCardsType {
  id: ID!
  name: String!
  rank: Int
  theme: String
  identifier: MaintenanceBoardListEnum
  createdAt: DateTime!
  updatedAt: DateTime!
  boardCards: [BoardCardForListType!]
}

type BoardType {
  id: ID!
  title: String!
  description: String
  category: BoardCategoryEnum
  icon: String
  members: [UserType!]
  projects: [ProjectType!]
  target: TargetType!
  boardCardsStats: BoardCardsStatsType
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum BoardCategoryEnum {
  PROJECTS
  MAINTENANCE
  CRM
}

type TimeEntryType {
  id: ID!
  member: UserType!
  card: BoardCardType!
  start: DateTime!
  end: DateTime!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type GenericTaskType {
  id: ID!
  title: String!
  description: String
  tags: [String!]
  priority: TaskPriorityEnum!
  dueDate: DateTime
  completed: Boolean!
  archived: Boolean!
  rank: Int!
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum TaskPriorityEnum {
  HIGH
  NORMAL
  LOW
}

type TaskSectionType {
  id: ID!
  title: String!
  description: String
  tags: [String!]
  priority: TaskPriorityEnum!
  dueDate: DateTime
  completed: Boolean!
  archived: Boolean!
  rank: Int!
  createdAt: DateTime!
  updatedAt: DateTime!
  target: TargetType!
}

type TicketType {
  id: ID!
  identifier: String!
  name: String
  description: String
  media: MediaType
  tags: [String!]
  deadline: DateTime
  priority: TicketPriorityEnum
  status: TicketStatusEnum
  color: String
  assignedTo: [UserType!]
  customer: CompanyType
  project: ProjectType
  attachments: [DocumentType!]
  target: TargetType
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum TicketPriorityEnum {
  LOW
  NORMAL
  HIGH
  CRITICAL
}

enum TicketStatusEnum {
  OPEN
  IN_PROGRESS
  RESOLVED
  BLOCKED
  ON_HOLD
}

type CommentHolderType {
  project: ProjectType
  card: BoardCardType
  ticket: TicketType
  quotation: QuotationType
  saleOrder: SaleOrderType
  saleIssueNote: SaleIssueNoteType
  saleInvoice: SaleInvoiceType
  saleDeliveryNote: SaleDeliveryNoteType
  purchaseDeliveryNote: PurchaseDeliveryNoteType
  purchaseInvoice: PurchaseInvoiceType
  purchaseOrder: PurchaseOrderType
}

type CommentBaseType {
  id: ID!
  user: UserType
  comment: String
  attachments: [DocumentType!]
  holder: CommentHolderType
  createdAt: DateTime!
  updatedAt: DateTime!
}

type FirstReplyType {
  reply: CommentBaseType
  hasMoreReplies: Boolean!
}

type CommentType {
  id: ID!
  user: UserType
  comment: String
  attachments: [DocumentType!]
  holder: CommentHolderType
  createdAt: DateTime!
  updatedAt: DateTime!
  firstReply: FirstReplyType
}

type TimeTrackOnType {
  project: ProjectType
  card: BoardCardType
  ticket: TicketType
}

type TimeTrackType {
  id: ID!
  user: UserType
  title: String
  start: DateTime
  end: DateTime
  idle: String
  holder: TimeTrackOnType
  createdAt: DateTime!
  updatedAt: DateTime!
}

type FixturePeriodType {
  first: Float
  second: String
}

type FixtureVenueType {
  id: Float
  name: String
  city: String
}

type FixtureStatusType {
  long: String
  short: String
  elapsed: Float
}

type FixtureLeagueType {
  id: Float
  name: String
  country: String
  logo: String
  logo64: String
  flag: String
  flag64: String
  season: Float
  round: String
}

type FixtureHAType {
  id: Float
  name: String
  logo: String
  logo64: String
  winner: Boolean
}

type FixtureGoalsType {
  home: Float
  away: Float
}

type FixtureTeamsType {
  home: FixtureHAType
  away: FixtureHAType
}

type FixtureScoreType {
  halftime: FixtureGoalsType
  fulltime: FixtureGoalsType
  extratime: FixtureGoalsType
  penalty: FixtureGoalsType
}

type FixtureSubType {
  id: Float
  referee: String
  timezone: String
  date: DateTime
  timestamp: Float
  periods: FixturePeriodType
  venue: FixtureVenueType
  status: FixtureStatusType
}

type FixtureType {
  id: ID!
  fixture: FixtureSubType
  league: FixtureLeagueType
  teams: FixtureTeamsType
  goals: FixtureGoalsType
  score: FixtureScoreType
  isUserSubscribedToFixtureEvents: Boolean
  createdAt: DateTime
  updatedAt: DateTime
}

type BetOrderOddsOddsType {
  extId: Int!
  name: String!
  value: String!
  odd: String!
}

type BetOrderOddsType {
  fixture: FixtureType!
  odds: [BetOrderOddsOddsType!]!
}

type BetOrderType {
  id: ID!
  user: UserType!
  bet: Float!
  maxWin: Float!
  finalWin: Float
  status: BetOrderStatus!
  odds: [BetOrderOddsType!]!
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum BetOrderStatus {
  ONGOING
  CONFIRMED
}

type BetOrderPaginateType {
  count: Int
  isLast: Boolean
  objects: [BetOrderType!]!
}

type VenueTypeFull {
  id: ID!
  venueId: Float
  name: String
  address: String
  city: String
  country: String
  capacity: Float
  surface: String
  image: String
}

type VenuePaginateType {
  count: Int
  isLast: Boolean
  objects: [VenueTypeFull!]!
}

type PackageType {
  id: ID!
  name: String!
  color: String
  description: String
  perks: [String!]
  price: String!
  delivrable: String!
  subscriptionCycle: SubscriptionCycleEnum!
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum SubscriptionCycleEnum {
  DAILY
  WEEKLY
  MONTHLY
  YEARLY
  ADHOC
}

type CoachsBirthType {
  date: DateTime
  place: String
  country: String
}

type CoachsTeamType {
  id: Float
  name: String
  logo: String
}

type CoachsCareerType {
  team: CoachsTeamType
  start: String
  end: String
}

type CoachsType {
  id: ID!
  coachId: Float
  name: String
  firstname: String
  lastname: String
  age: Float
  birth: CoachsBirthType
  nationality: String
  height: String
  weight: String
  photo: String
  photo64: String
  team: CoachsTeamType
  career: [CoachsCareerType!]
}

type CoachsPaginateType {
  count: Int
  isLast: Boolean
  objects: [CoachsType!]!
}

type TimezoneType {
  id: ID!
  timezone: String!
}

type TimezonePaginateType {
  count: Int
  isLast: Boolean
  objects: [TimezoneType!]!
}

type InjuriesPlayerType {
  id: Float
  name: String
  photo: String
  type: String
  reason: String
}

type InjuriesTeamType {
  id: Float
  name: String
  logo: String
}

type InjuriesFixtureType {
  id: Float
  timezone: String
  date: DateTime
  timestamp: Float
}

type InjuriesLeagueType {
  id: Float
  season: Float
  name: String
  country: String
  logo: String
  flag: String
}

type InjuriesType {
  id: ID!
  player: InjuriesPlayerType
  team: InjuriesTeamType
  fixture: InjuriesFixtureType
  league: InjuriesLeagueType
}

type InjuriesPaginateType {
  count: Int
  isLast: Boolean
  objects: [InjuriesType!]!
}

type APITargetType {
  coach: Int
  player: Int
}

type TrophiesInnerType {
  league: String
  country: String
  season: String
  place: String
}

type TrophiesType {
  id: ID!
  target: APITargetType!
  trophies: [TrophiesInnerType!]!
}

type TrophiesPaginateType {
  count: Int
  isLast: Boolean
  objects: [TrophiesType!]!
}

type CountryProviderType {
  id: ID
  name: String
  code: String
  flag: String
  flag64: String
}

type CountryPaginateType {
  count: Int
  isLast: Boolean
  objects: [CountryProviderType!]!
}

type StandingStatGoalsType {
  for: Float
  against: Float
}

type StandingTeamType {
  id: Float
  name: String
  logo: String
}

type StandingStatType {
  played: Float
  win: Float
  lose: Float
  goals: StandingStatGoalsType
}

type StandingType {
  rank: Float
  team: StandingTeamType
  points: Float
  goalsDiff: Float
  group: String
  form: String
  status: String
  description: String
  all: StandingStatType
  home: StandingStatType
  away: StandingStatType
  update: DateTime
}

type StandingLeagueType {
  id: Int
  name: String
  country: String
  logo: String
  flag: String
  season: Float
  standings: [[StandingType!]!]
}

type StandingsType {
  id: ID!
  league: StandingLeagueType
}

type StandingPaginateType {
  count: Int
  isLast: Boolean
  objects: [StandingsType!]!
}

type RoundType {
  id: ID!
  league: Int!
  season: Int!
  rounds: [String!]!
}

type RoundPaginateType {
  count: Int
  isLast: Boolean
  objects: [RoundType!]!
}

type SquadsTeamType {
  id: Float
  name: String
  logo: String
}

type SquadsPlayersType {
  id: Float
  name: String
  age: Float
  number: Float
  position: String
  photo: String
}

type SquadsType {
  id: ID!
  team: SquadsTeamType
  players: [SquadsPlayersType!]
}

type SquadsPaginateType {
  count: Int
  isLast: Boolean
  objects: [SquadsType!]!
}

type SeasonType {
  id: ID!
  season: String!
}

type SeasonPaginateType {
  count: Int
  isLast: Boolean
  objects: [SeasonType!]!
}

type EventsTeamType {
  id: Float
  name: String
  logo: String
}

type EventsPlayerType {
  id: Float
  name: String
}

type EventsTimeType {
  elapsed: Float
  extra: Float
}

type EventsType {
  id: ID!
  fixture: Int
  time: EventsTimeType
  team: EventsTeamType
  player: EventsPlayerType
  assist: EventsPlayerType
  type: String
  detail: String
  comments: String
}

type EventsPaginateType {
  count: Int
  isLast: Boolean
  objects: [EventsType!]!
}

type TransfersPlayerType {
  id: Float
  name: String
}

type TransfersTransfersTeamsInOutType {
  id: Float
  name: String
  logo: String
}

type TransfersTransfersTeamsType {
  in: TransfersTransfersTeamsInOutType
  out: TransfersTransfersTeamsInOutType
}

type TransfersTransfersType {
  date: DateTime
  type: String
  teams: TransfersTransfersTeamsType
}

type TransfersType {
  id: ID!
  player: TransfersPlayerType
  updateAt: DateTime
  transfers: [TransfersTransfersType!]
}

type TransfersPaginateType {
  count: Int
  isLast: Boolean
  objects: [TransfersType!]!
}

type SidelinedInnerType {
  type: String
  start: DateTime
  end: DateTime
}

type SidelinedType {
  id: ID!
  target: APITargetType!
  sideLined: [SidelinedInnerType!]!
}

type SidelinedPaginateType {
  count: Int
  isLast: Boolean
  objects: [SidelinedType!]!
}

type LeagueObjType {
  id: Int!
  name: String
  logo: String
  logo64: String
  type: LeagueTypeEnum
}

enum LeagueTypeEnum {
  Cup
  League
}

type LeagueFixtureType {
  events: Boolean
  lineups: Boolean
  statistics_fixtures: Boolean
  statistics_players: Boolean
}

type CoverageType {
  fixtures: LeagueFixtureType
  standings: Boolean
  players: Boolean
  top_scorers: Boolean
  top_assists: Boolean
  top_cards: Boolean
  injuries: Boolean
  predictions: Boolean
  odds: Boolean
}

type LeagueType {
  id: ID!
  league: LeagueObjType
  country: CountryProviderType
  seasons: [SeasonsType!]
}

type SeasonsType {
  year: String
  start: DateTime
  end: DateTime
  current: Boolean
  coverage: CoverageType
}

type LeaguePaginateType {
  count: Int
  isLast: Boolean
  objects: [LeagueType!]!
}

type PlayersPlayerBirthType {
  date: DateTime
  place: String
  country: String
}

type PlayersPlayerType {
  id: Float
  name: String
  firstname: String
  lastname: String
  age: Float
  birth: PlayersPlayerBirthType
  nationality: String
  height: String
  weight: String
  injured: String
  photo: String
  photo64: String
}

type PlayersStatisticsTeamType {
  id: Float
  name: String
  logo: String
}

type PlayersStatisticsLeagueType {
  id: Float
  name: String
  country: String
  logo: String
  flag: String
  season: String
}

type PlayersStatisticsGamesType {
  appearences: Float
  lineups: Float
  minutes: Float
  number: Float
  position: String
  rating: String
  captain: Boolean
}

type PlayersStatisticsSubstituesType {
  in: Float
  out: Float
  bench: Float
}

type PlayersStatisticsShotsType {
  total: Float
  on: Float
}

type PlayersStatisticsGoalsType {
  total: Float
  conceded: Float
  assists: Float
  saves: Float
}

type PlayersStatisticsPassesType {
  total: Float
  key: Float
  accuracy: Float
}

type PlayersStatisticsTacklesType {
  total: Float
  blocks: Float
  interceptions: Float
}

type PlayersStatisticsDuelsType {
  total: Float
  won: Float
}

type PlayersStatisticsDribblesType {
  attempts: Float
  success: Float
  past: Float
}

type PlayersStatisticsFoulsType {
  drawn: Float
  committed: Float
}

type PlayersStatisticsCardsType {
  yellow: Float
  yellowred: Float
  red: Float
}

type PlayersStatisticsPenaltyType {
  won: Float
  commited: Float
  scored: Float
  missed: Float
  saved: Float
}

type PlayersStatisticsType {
  team: PlayersStatisticsTeamType
  league: PlayersStatisticsLeagueType
  games: PlayersStatisticsGamesType
  substitutes: PlayersStatisticsSubstituesType
  shots: PlayersStatisticsShotsType
  goals: PlayersStatisticsGoalsType
  passes: PlayersStatisticsPassesType
  tackles: PlayersStatisticsTacklesType
  duels: PlayersStatisticsDuelsType
  dribbles: PlayersStatisticsDribblesType
  fouls: PlayersStatisticsFoulsType
  cards: PlayersStatisticsCardsType
  penalty: PlayersStatisticsPenaltyType
}

type PlayersStatsType {
  id: ID!
  player: PlayersPlayerType
  statistics: [PlayersStatisticsType!]
}

type PlayersStatsPaginateType {
  count: Int
  isLast: Boolean
  objects: [PlayersStatsType!]!
}

type LineupColorIntType {
  primary: String
  number: String
  border: String
}

type LineupColorType {
  player: LineupColorIntType
  goalkeeper: LineupColorIntType
}

type LineupTeamType {
  id: Float
  name: String
  logo: String
  colors: LineupColorType
}

type LineupPlayerType {
  id: Float
  name: String
  number: Float
  pos: String
  grid: String
}

type LineupStartXIType {
  player: LineupPlayerType
}

type LineupCoachType {
  id: Float
  name: String
  photo: String
}

type LineupsType {
  id: ID!
  fixture: Int
  team: LineupTeamType
  formation: String
  startXI: [LineupStartXIType!]
  substitutes: [LineupStartXIType!]
  coach: LineupCoachType
}

type LineupsPaginateType {
  count: Int
  isLast: Boolean
  objects: [LineupsType!]!
}

type FixturePaginateType {
  count: Int
  isLast: Boolean
  objects: [FixtureType!]!
}

type LeagueWithFixturesType {
  id: Int!
  name: String
  logo: String
  flag: String
  season: Int
  country: String
  fixtures: [FixtureType!]
}

type DateFixturesType {
  id: ID!
  year: Int!
  month: Int!
  day: Int!
  leaguesFixtures: LeagueWithFixturesType!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type LeagueWithFixturesPaginatedType {
  count: Int
  isLast: Boolean
  objects: [LeagueWithFixturesType!]!
}

type UserPackageType {
  id: ID!
  user: UserType!
  package: PackageType!
  expiresIn: DateTime!
  autoRenew: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type BetsBookmakersType {
  id: ID!
  extId: Float
  name: String
}

type BetsBookmakersPaginateType {
  count: Int
  isLast: Boolean
  objects: [BetsBookmakersType!]!
}

type OddsBookmakersBetsValuesType {
  value: String
  odd: String
}

type OddsLeagueType {
  id: Float
  name: String
  country: String
  logo: String
  flag: String
  season: Float
}

type OddsFixtureType {
  id: Float
  timezone: String
  date: DateTime
  timestamp: String
}

type OddsBookmakersBetsType {
  id: Float
  name: String
  values: [OddsBookmakersBetsValuesType!]
}

type OddsBookmakersType {
  id: Float
  name: String
  bets: [OddsBookmakersBetsType!]
}

type OddsType {
  id: ID!
  league: OddsLeagueType
  fixture: OddsFixtureType
  updateAt: DateTime
  bookmakers: [OddsBookmakersType!]
}

type OddsPaginateType {
  count: Int
  isLast: Boolean
  objects: [OddsType!]!
}

type StatHATType {
  home: Float
  away: Float
  total: Float
}

type StatWDLType {
  wins: Float
  draws: Float
  loses: Float
}

type StatHAType {
  home: String
  away: String
}

type StatTPType {
  total: Float
  percentage: String
}

type StatTAType {
  total: Float
  average: String
}

type StatMinuteType {
  zeroToFifteen: StatTPType
  sixteenToThirty: StatTPType
  thirtyoneToFourtyfive: StatTPType
  fourtysixToSixty: StatTPType
  fixtyoneToSeventyfive: StatTPType
  seventysixToNinety: StatTPType
  ninetyoneToHundredfive: StatTPType
  hundredsixToHundredtwenty: StatTPType
}

type PredictionsComparisonType {
  form: StatHAType
  att: StatHAType
  def: StatHAType
  poisson_distribution: StatHAType
  h2h: StatHAType
  goals: StatHAType
  total: StatHAType
}

type PredictionsTeamsHomeLast5GoalsType {
  for: StatTAType
  against: StatTAType
}

type PredictionsTeamsHomeLast5Type {
  form: String
  att: String
  def: String
  goals: PredictionsTeamsHomeLast5GoalsType
}

type PredictionsTeamsHomeLeagueFixturesType {
  played: StatHATType
  wins: StatHATType
  draws: StatHATType
  loses: StatHATType
}

type PredictionsTAMType {
  total: StatHATType
  average: StatHATType
  minute: StatMinuteType
}

type PredictionsTeamsHomeLeagueGoalsType {
  for: PredictionsTAMType
  against: PredictionsTAMType
}

type PredictionsTeamsHomeLeagueBiggestStreakType {
  wins: Float
  draws: Float
  loses: Float
}

type PredictionsTeamsHomeLeagueBiggestGoalsType {
  for: StatHAType
  against: StatHAType
}

type PredictionsTeamsHomeLeagueBiggestType {
  streak: PredictionsTeamsHomeLeagueBiggestStreakType
  wins: StatHAType
  loses: StatHAType
  goals: PredictionsTeamsHomeLeagueBiggestGoalsType
}

type PredictionsTeamsHomeLeaguePenaltyType {
  scored: StatTPType
  missed: StatTPType
  total: Float
}

type PredictionsTeamsHomeLeagueCardsType {
  yellow: StatMinuteType
  red: StatMinuteType
}

type PredictionsTeamsHomeLeagueType {
  form: String
  fixtures: PredictionsTeamsHomeLeagueFixturesType
  goals: PredictionsTeamsHomeLeagueGoalsType
  biggest: PredictionsTeamsHomeLeagueBiggestType
  clean_sheet: StatHATType
  failed_to_score: StatHATType
  penalty: PredictionsTeamsHomeLeaguePenaltyType
  cards: PredictionsTeamsHomeLeagueCardsType
}

type PredictionsTeamsHomeType {
  id: Float
  name: String
  logo: String
  last_5: PredictionsTeamsHomeLast5Type
  league: PredictionsTeamsHomeLeagueType
}

type PredictionsTeamsType {
  home: PredictionsTeamsHomeType
  away: PredictionsTeamsHomeType
}

type PredictionsH2HFixturePeriodsType {
  first: Float
  second: Float
}

type PredictionsH2HFixtureVenueType {
  id: Float
  name: String
  city: String
}

type PredictionsH2HFixtureStatusType {
  long: String
  short: String
  elapsed: Float
}

type PredictionsH2HFixtureType {
  id: Float
  referee: String
  timezone: String
  date: DateTime
  timestamp: Float
  periods: PredictionsH2HFixturePeriodsType
  venue: PredictionsH2HFixtureVenueType
  status: PredictionsH2HFixtureStatusType
}

type PredictionsH2HLeagueType {
  id: Float
  name: String
  country: String
  logo: String
  flag: String
  season: Float
  round: String
}

type PredictionsH2HTeamsHAType {
  id: Float
  name: String
  logo: String
  winner: Boolean
}

type PredictionsH2HTeamsType {
  home: PredictionsH2HTeamsHAType
  away: PredictionsH2HTeamsHAType
}

type PredictionsH2HScoreType {
  halftime: StatHAType
  fulltime: StatHAType
  extratime: StatHAType
  penalty: StatHAType
}

type PredictionsH2HType {
  fixture: PredictionsH2HFixtureType
  league: PredictionsH2HLeagueType
  teams: PredictionsH2HTeamsType
  goals: StatHAType
  score: PredictionsH2HScoreType
}

type PredictionsWinnerType {
  id: Float
  name: String
  comment: String
}

type PredictionsPercentType {
  home: String
  draw: String
  away: String
}

type PredictionsPredictionsType {
  winner: PredictionsWinnerType
  win_or_draw: Boolean
  under_over: String
  goals: StatHAType
  advice: String
  percent: PredictionsPercentType
}

type PredictionsLeagueType {
  id: Float
  name: String
  country: String
  logo: String
  flag: String
  season: Float
}

type PredictionsType {
  id: ID!
  fixture: Int!
  predictions: PredictionsPredictionsType
  league: PredictionsLeagueType
  teams: PredictionsTeamsType
  comparison: PredictionsComparisonType
  h2h: [PredictionsH2HType!]
}

type PredictionsPaginateType {
  count: Int
  isLast: Boolean
  objects: [PredictionsType!]!
}

type TeamType {
  id: String
  name: String
  country: String
  founded: Float
  national: String
  logo: String
  logo64: String
}

type VenueType {
  id: String
  name: String
  address: String
  city: String
  capacity: Float
  surface: String
  image: String
  image64: String
}

type TeamInformationType {
  id: ID!
  team: TeamType
  venue: VenueType
}

type TeamInformationPaginateType {
  count: Int
  isLast: Boolean
  objects: [TeamInformationType!]!
}

type FavoriteTeamType {
  id: ID!
  user: UserType!
  team: TeamInformationType!
}

type FavoriteTeamPaginateType {
  count: Int
  isLast: Boolean
  objects: [FavoriteTeamType!]!
}

type InPlayOddsLeagueType {
  id: Float
  season: Float
}

type InPlayOddsFixtureStatusType {
  long: String
  elapsed: Float
  seconds: String
}

type InPlayOddsFixtureType {
  id: Float
  status: InPlayOddsFixtureStatusType
}

type InPlayOddsBookmakersValueType {
  value: String
  odd: String
  handicap: String
  main: Boolean
  suspended: Boolean
}

type InPlayOddsBookmakersType {
  id: Float
  name: String
  values: [InPlayOddsBookmakersValueType!]
}

type InPlayOddsTeamsHAType {
  id: Float
  goals: Float
}

type InPlayOddsTeamsType {
  home: InPlayOddsTeamsHAType
  away: InPlayOddsTeamsHAType
}

type InPlayOddsStatusType {
  stopped: Boolean
  blocked: Boolean
  finished: Boolean
}

type InPlayOddsType {
  id: ID!
  fixture: InPlayOddsFixtureType
  league: InPlayOddsLeagueType
  teams: InPlayOddsTeamsType
  status: InPlayOddsStatusType
  update: DateTime
  odds: [InPlayOddsBookmakersType!]
}

type InPlayOddsPaginateType {
  count: Int
  isLast: Boolean
  objects: [InPlayOddsType!]!
}

type TopScorersType {
  id: ID!
  league: Int
  season: Int
  topScorers: [PlayersStatsType!]
}

type TopScorerPaginateType {
  count: Int
  isLast: Boolean
  objects: [TopScorersType!]!
}

type StatisticsTeamsType {
  id: Float
  name: String
  logo: String
}

type StatisticsIntType {
  type: String
  value: String
}

type StatisticsType {
  id: ID!
  fixture: Int
  team: StatisticsTeamsType
  statistics: [StatisticsIntType!]
}

type StatisticsPaginateType {
  count: Int
  isLast: Boolean
  objects: [StatisticsType!]!
}

type TopAssistsType {
  id: ID!
  league: Int
  season: Int
  topAssists: [PlayersStatsType!]
}

type TopAssistsPaginateType {
  count: Int
  isLast: Boolean
  objects: [TopAssistsType!]!
}

type EventSubscriptionType {
  id: ID!
  fixture: FixtureType!
  user: UserType!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type PaginatedEventSubscriptionType {
  count: Int
  isLast: Boolean
  objects: [EventSubscriptionType!]!
}

type MappingLeagueType {
  id: Float
  season: Float
}

type MappingFixtureType {
  id: Float
  date: DateTime
  timestamp: Float
}

type TeamSeasonsType {
  id: ID!
  team: Float
  seasons: [Float!]
}

type TeamSeasonsPaginateType {
  count: Int
  isLast: Boolean
  objects: [TeamSeasonsType!]!
}

type PlayerSeasonType {
  id: ID!
  player: Float!
  season: [Int!]!
  createdAt: DateTime
  updatedAt: DateTime
}

type TopRedCardsType {
  id: ID!
  league: Int
  season: Int
  topRedCards: [PlayersStatsType!]
}

type TopRedCardsPaginateType {
  count: Int
  isLast: Boolean
  objects: [TopRedCardsType!]!
}

type StatLeagueType {
  id: String
  name: String
  country: String
  logo: String
  flag: String
  season: Float
}

type StatTeamType {
  id: String
  name: String
  logo: String
}

type StatFixturesType {
  played: StatHATType
  wins: StatHATType
  draws: StatHATType
  loses: StatHATType
}

type StatTAMType {
  total: StatHATType
  average: StatHATType
  minute: StatMinuteType
}

type StatGoalsType {
  for: StatTAMType
  against: StatTAMType
}

type StatFAType {
  for: StatHAType
  against: StatHAType
}

type StatBiggestType {
  streak: StatWDLType
  wins: StatHAType
  loses: StatHAType
  goals: StatFAType
}

type StatPenaltynterface {
  scored: StatTPType
  missed: StatTPType
  total: Float
}

type StatFPnterface {
  formation: String
  played: Float
}

type StatCardsnterface {
  yellow: StatMinuteType
  red: StatMinuteType
}

type TeamStatisticsType {
  id: ID
  league: StatLeagueType
  team: StatTeamType
  form: String
  fixtures: StatFixturesType
  goals: StatGoalsType
  biggest: StatBiggestType
  clean_sheet: StatHATType
  failed_to_score: StatHATType
  penalty: StatPenaltynterface
  lineups: [StatFPnterface!]
  cards: StatCardsnterface
}

type TeamStatisticsPaginateType {
  count: Int
  isLast: Boolean
  objects: [TeamStatisticsType!]!
}

type TopYellowCardsType {
  id: ID!
  league: Int
  season: Int
  topYellowCards: [PlayersStatsType!]
}

type TopYellowCardsPaginateType {
  count: Int
  isLast: Boolean
  objects: [TopYellowCardsType!]!
}

type FavoriteLeagueType {
  id: ID!
  user: UserType!
  league: LeagueType!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type FavoriteLeaguePaginateType {
  count: Int
  isLast: Boolean
  objects: [FavoriteLeagueType!]!
}

type PlayerStatisticsTeamType {
  id: Float
  name: String
  logo: String
  update: DateTime
}

type PlayerStatisticsPlayerType {
  id: Float
  name: String
  photo: String
}

type PlayerStatisticsGamesType {
  minutes: Float
  number: Float
  position: String
  rating: String
  captain: Boolean
  substitute: Boolean
}

type PlayerStatisticsShotsType {
  total: Float
  on: Float
}

type PlayerStatisticsGoalsType {
  total: Float
  conceded: Float
  assists: Float
  saves: Float
}

type PlayerStatisticsPassesType {
  total: Float
  key: Float
  accuracy: String
}

type PlayerStatisticsTacklesType {
  total: Float
  blocks: Float
  interceptions: Float
}

type PlayerStatisticsDuelsType {
  total: Float
  won: Float
}

type PlayerStatisticsDribblesType {
  attempts: Float
  success: Float
  past: Float
}

type PlayerStatisticsFoulsType {
  drawn: Float
  committed: Float
}

type PlayerStatisticsCardsType {
  yellow: Float
  red: Float
}

type PlayerStatisticsPenaltyType {
  won: Float
  commited: Float
  scored: Float
  missed: Float
  saved: Float
}

type PlayerStatisticsStatisticsType {
  games: PlayerStatisticsGamesType
  offsides: Float
  shots: PlayerStatisticsShotsType
  goals: PlayerStatisticsGoalsType
  passes: PlayerStatisticsPassesType
  tackles: PlayerStatisticsTacklesType
  duels: PlayerStatisticsDuelsType
  dribbles: PlayerStatisticsDribblesType
  fouls: PlayerStatisticsFoulsType
  cards: PlayerStatisticsCardsType
  penalty: PlayerStatisticsPenaltyType
}

type PlayerStatisticsPlayersType {
  player: PlayerStatisticsPlayerType
  statistics: [PlayerStatisticsStatisticsType!]
}

type PlayerStatisticsType {
  id: ID!
  fixture: Int
  team: PlayerStatisticsTeamType
  players: [PlayerStatisticsPlayersType!]
}

type PlayerStatisticsPaginateType {
  count: Int
  isLast: Boolean
  objects: [PlayerStatisticsType!]!
}

type FavoriteLeagueDefinitionType {
  id: ID
  league: LeagueType
  createdAt: DateTime!
  updatedAt: DateTime!
}

type FavoriteLeagueDefinitionPaginateType {
  count: Int
  isLast: Boolean
  objects: [FavoriteLeagueDefinitionType!]!
}

type WalletTransactionType {
  id: ID!
  user: UserType!
  pocketType: PocketTypeEnum!
  transactionType: WalletTransactionTypeEnum!
  transactionReason: WalletTransactionReasonEnum!
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum WalletTransactionTypeEnum {
  IN
  OUT
}

enum WalletTransactionReasonEnum {
  SUBSCRIPTION
  ADHOC_TOPUP
  GAME_FEES
  GAME_WIN
}

type WalletTransactionPaginateType {
  count: Int
  isLast: Boolean
  objects: [WalletTransactionType!]!
}

type FavoriteTeamDefinitionType {
  id: ID
  teamInformation: TeamInformationType
  createdAt: DateTime!
  updatedAt: DateTime!
}

type FavoriteTeamDefinitionPaginateType {
  count: Int
  isLast: Boolean
  objects: [FavoriteTeamDefinitionType!]!
}

type PlayFixturesType {
  id: ID!
  year: Int!
  month: Int!
  day: Int!
  fixtures: [FixtureType!]!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type Query {
  loginForApp(input: LoginInput!): LoginType!
  login(input: LoginInput!): LoginType!
  loginWithFacebook(token: String!): LoginType!
  loginWithGoogle(token: String!): LoginType!
  loginWithApple(authorizationData: AuthorizationDataInput!): LoginType!
  getUsersPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): UserPaginateType!
  getRoles: StringListType!
  getGenders: StringListType!
  getMaritalStatuses: StringListType!
  getUsers: [UserType!]!
  getUsersPaginated(
    status: [UserStatus!]
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): UserPaginateType!
  user(id: String!): UserType!
  currentUser: UserType!
  userByEmail(email: String!): UserType!
  searchUser(
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String
  ): UserPaginateType!
  isLoggedIn: IsLoggedInType!
  isLoginExist(input: IsLoginExistInput!): UserExistType!
  isEmailExist(email: String!): UserExistType!
  getVapidKey(userId: String): VapidKeyType!
  getOrigins: [OriginType!]!
  generateCloudinarySignature(
    public_id: String
    folder: String!
  ): CloudinarySignatureType!
  getImagesFromFolder(path: String!): [CloudinaryResourceType!]!
  getGuidanceTypes: StringListType!
  getCurrencies: StringListType!
  getApps: StringListType!
  getBrandColors: [KeyValueListType!]!
  getOrderStatuses: StringListType!
  getDiscountTypes: StringListType!
  getChatContacts: StringListType!
  getSocialMedias: StringListType!
  uploadImage(remotePath: String!, localPath: String!): PictureType!
  getVersions: [VersionType!]!
  getVersion(id: String!): VersionType!
  getByVersion(version: String!): VersionType!
  getLastVersion: VersionType!
  getLastVersionByPlatform(platform: PlatformEnum!): VersionType!
  getVersionsPaginated(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): VersionsPaginateType!
  countUnseenNotificationsByPOS(posId: String!): UnseenNotificationCountType!
  countUnseenNotificationsByUser: UnseenNotificationCountType!
  sendAdhocNotificationTest(
    picture: PictureInput!
    description: String!
    userId: String!
    title: String!
  ): AdhocNotificationTestType!
  sendUserAdhocNotification(
    executedAt: DateTime
    picture: PictureInput!
    description: String!
    userId: String!
    title: String!
  ): AdhocNotificationTestType!
  sendAdhocNotificationToTopicTest(
    picture: PictureInput!
    description: String!
    topic: String!
    title: String!
  ): AdhocNotificationTestType!
  getEventSubscriptions: [EventSubscriptionType!]!
  getEventSubscription(id: ID!): EventSubscriptionType!
  getEventSubscriptionPaginated(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): PaginatedEventSubscriptionType!
  getAuthDashboardData(
    apps: [App!]
    to: DateTime
    from: DateTime
  ): AuthDashboardType!
  getAuthDashboardDataByApp(
    to: DateTime
    from: DateTime
  ): AuthDashboardByAppType!
  getCockpitDashboardPreviewByApp: AuthDashboardPreviewByAppType!
  getCockpitDashboardAnalyticsByApp: GetCockPitDashboardAnalyticsByAppType!
  getCockpitDashboardUsersAnalyticsByApp(
    to: DateTime!
    from: DateTime!
  ): GetCockPitDashboardUserAnalyticsByAppType!
  getCockpitDashboardSessionsAnalyticsByApp(
    to: DateTime!
    from: DateTime!
  ): [DurationsCountType!]!
  validateRegisterPhoneNumber(smsNumber: Int!, phone: IPhoneInput!): SmsLogType!
  sendSms(
    time: String!
    date: String!
    smsContent: String!
    phoneNumber: String!
  ): SmsIntegrationType!
  getTimezones: [TimezoneType!]!
  getTimezonesPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): TimezonePaginateType!
  timezone(id: ID!): TimezoneType!
  fetchTimezones: [TimezoneType!]!
  getCountries: [CountryType!]!
  getCountriesPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): CountryPaginateType!
  country(id: ID!): CountryProviderType!
  getCountryByFilter(filter: CountryProviderInput!): [CountryProviderType!]!
  fetchCountries: [CountryProviderType!]!
  getSeasons: [SeasonType!]!
  getSeasonsPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): SeasonPaginateType!
  season(id: ID!): SeasonType!
  fetchSeasons: [SeasonType!]!
  getLeaguePagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): LeaguePaginateType!
  league(id: ID!): LeagueType!
  findOneByLeague(leagueId: Int!): LeagueType!
  getLeaguesByFilter(filter: LeagueFilterInput!): [LeagueType!]!
  searchLeagues(
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String
  ): LeaguePaginateType!
  fetchLeagues: [LeagueType!]!
  getTeamsInformationPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): TeamInformationPaginateType!
  teamInformation(id: ID!): TeamInformationType!
  findOneByTeamId(teamId: Int!): TeamInformationType!
  getTeamsByFilter(filter: TeamInformationFilterInput!): [TeamInformationType!]!
  getTeamsInformationFromProvider: [TeamInformationType!]!
  searchTeam(
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String
  ): TeamInformationPaginateType!
  getTeamStatisticsPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): TeamStatisticsPaginateType!
  teamStatistics(id: ID!): TeamStatisticsType!
  getTeamStatistics(team: Int!, season: Int!, league: Int!): TeamStatisticsType!
  getTeamSeasonsPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): TeamSeasonsPaginateType!
  teamSeasons(id: ID!): TeamSeasonsType!
  getTeamSeasons(team: Int!): TeamSeasonsType!
  getVenuesPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): VenuePaginateType!
  getVenuesFromProvider: [VenueTypeFull!]!
  searchVenues(searchString: String): [VenueTypeFull!]!
  getStandingsPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): StandingPaginateType!
  standings(id: ID!): StandingsType!
  getStandings(season: Int!, team: Int, league: Int): [StandingsType!]!
  getRoundsPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): RoundPaginateType!
  round(id: ID!): RoundType!
  getRounds(season: Int!, league: Int!): [RoundType!]!
  getFixturesPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): FixturePaginateType!
  fixture(id: ID!): FixtureType!
  findOneByFixtureId(fixtureId: Int!): FixtureType!
  getFixturesWithFilter(
    filter: FixtureFilterInput!
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): FixturePaginateType!
  getHeadToHead(
    season: Int
    league: Int
    secondTeam: Int!
    firstTeam: Int!
  ): [FixtureType!]!
  getPlayOffsByRound(
    round: RoundsEnum!
    season: Int!
    league: Int!
  ): [FixtureType!]!
  getFixturesFromProvider(
    league: Int!
    season: Int!
    round: String
    to: DateTime
    from: DateTime
  ): [FixtureType!]!
  searchLeaguesWithFixtures(
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String
    date: DateTime!
  ): LeagueWithFixturesPaginatedType!
  getLiveFixtures: [FixtureType!]!
  getUserFavoriteLiveFixtures(id: ID): [FixtureType!]!
  searchLiveFixtures(searchString: String): [FixtureType!]!
  getStatisticsPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): StatisticsPaginateType!
  statistics(id: String!): StatisticsType!
  getStatisticsFromProvider(fixture: Int!): [StatisticsType!]!
  getLiveStatisticsFromProvider(fixture: Int!): [StatisticsType!]!
  getEventsPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): EventsPaginateType!
  events(id: String!): LineupsType!
  getEventsFromProvider(fixture: Int!): [EventsType!]!
  getLineupsPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): LineupsPaginateType!
  getLineupsFromProvider(fixture: Int!): [LineupsType!]!
  getActivityLogs: [ActivityLogType!]!
  ActivityLog(id: String!): ActivityLogType!
  getPosTransactions(
    pagination: PaginationInput = { page: 0, limit: 20 }
    activityType: [ActivityLogTypeEnum!]
    posId: String!
  ): ActivityLogPaginateType!
  getTargetTransactions(
    pagination: PaginationInput = { page: 0, limit: 20 }
    activityType: [ActivityLogTypeEnum!]
    user: ID
    searchString: String
    target: TargetACIInput!
  ): ActivityLogPaginateType!
  getTargetTransactionsByExcel(
    path: String
    activityType: [ActivityLogTypeEnum!]
    user: ID
    searchString: String
    target: TargetACIInput!
  ): InvoicePDFType!
  sendTargetTransactionsBymail(
    activityType: [ActivityLogTypeEnum!]
    subject: String!
    emails: [String!]
    searchString: String
    target: TargetACIInput
  ): MailResponseDto!
  getActivityLogsPagination(
    status: [ActivityLogTypeEnum!]
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): ActivityLogPaginateType!
  getPlayerStatisticsPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): PlayerStatisticsPaginateType!
  playerStatistics(id: String!): PlayerStatisticsType!
  getPlayerStatisticsFromProvider(fixture: Int!): [PlayerStatisticsType!]!
  getInjuriesPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): InjuriesPaginateType!
  getInjury(id: ID!): InjuriesType!
  getInjuriesWithFilter(
    filter: InjuriesFilterInput!
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): InjuriesPaginateType!
  getInjuriesFromProvider(fixture: Int!): [InjuriesType!]!
  getPredictionsPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): PredictionsPaginateType!
  predictions(id: ID!): PredictionsType!
  getPredictions(fixture: Int!): PredictionsType!
  getCoachsPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): CoachsPaginateType!
  coachs(id: ID!): CoachsType!
  findOneByCoachId(coachId: Int!): CoachsType!
  getCoachesFromProvider(team: Int!): [CoachsType!]!
  searchCoaches(
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String
  ): CoachsPaginateType!
  playerSeasons(player: Int!): PlayerSeasonType!
  getPlayersPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): PlayersStatsPaginateType!
  getPlayer(id: ID!): PlayersStatsType!
  getPlayerById(season: Int!, id: Int!): PlayersStatsType!
  getPlayersStatsFromProvider(season: Int!, league: Int!): [PlayersStatsType!]!
  getAllByPlayerPlayersStatsFromProvider(player: Int!): [PlayersStatsType!]!
  getPlayersStatsWithFilter(
    pagination: PaginationInput = { page: 0, limit: 20 }
    filter: PlayersStatsFilterInput!
  ): PlayersStatsPaginateType!
  searchPlayers(
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String
  ): PlayersStatsPaginateType!
  getSquadsPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): SquadsPaginateType!
  squads(id: ID!): SquadsType!
  getTeamOrPlayerSquads(player: Int, team: Int): [SquadsType!]!
  getSquadsFromProvider(team: Int): [SquadsType!]!
  getTopScorerPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): TopScorerPaginateType!
  topScorer(id: ID!): TopScorersType!
  getTopScorers(season: Int!, league: Int!): TopScorersType!
  getTopAssistsPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): TopAssistsPaginateType!
  topAssists(id: ID!): TopAssistsType!
  getTopAssists(season: Int!, league: Int!): [TopAssistsType!]!
  getTopYellowCardsPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): TopYellowCardsPaginateType!
  topYellowCards(id: ID!): PlayersStatsType!
  getTopYellowCards(season: Int!, league: Int!): TopYellowCardsType!
  getTopRedCardsPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): TopRedCardsPaginateType!
  topRedCards(id: ID!): TopRedCardsType!
  getTopRedCards(season: Int!, league: Int!): [TopRedCardsType!]!
  getTransfersPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): TransfersPaginateType!
  transfers(id: ID!): TransfersType!
  getTransfers(player: Int, team: Int): [TransfersType!]!
  getTransfersFromProvider(player: Int, team: Int): [TransfersType!]!
  getTrophiesPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): TrophiesPaginateType!
  trophies(id: ID!): TrophiesType!
  getTrophies(player: Int, coach: Int): TrophiesType!
  getSidelinedPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): SidelinedPaginateType!
  sidelined(id: ID!): SidelinedType!
  getSidelined(player: Int, coach: Int): SidelinedType!
  getPreMatchOddsPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): OddsPaginateType!
  preMatchOdds(id: ID!): OddsType!
  isFixtureGotPreMatchOdds(id: Int!): BooleanCheckType!
  getPreMatchOddsWithFilter(
    pagination: PaginationInput = { page: 0, limit: 20 }
    filter: OddsFilterInput!
  ): OddsPaginateType!
  getPreMatchOddsFromProvider(fixtureId: Int!): [OddsType!]!
  getBookmakersPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): BetsBookmakersPaginateType!
  bookmakers(id: ID!): BetsBookmakersType!
  getBookmakerByExtId(extId: Int!): BetsBookmakersType!
  fetchBookmakers: [BetsBookmakersType!]!
  getBetsPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): BetsBookmakersPaginateType!
  bets(id: ID!): BetsBookmakersType!
  getBetsByExtId(extId: Int!): BetsBookmakersType!
  fetchBets: [BetsBookmakersType!]!
  getInPlayBetsPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): BetsBookmakersPaginateType!
  inPlayBets(id: ID!): BetsBookmakersType!
  getInPlayBetsByExtId(extId: Int!): BetsBookmakersType!
  fetchInPlayBets: [BetsBookmakersType!]!
  getInPlayOddsPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): InPlayOddsPaginateType!
  inPlayOdds(id: ID!): InPlayOddsType!
  isFixtureGotInPlayOdds(id: ID!): BooleanCheckType!
  getInPlayOddsFromProvider(fixtureId: Int!): [InPlayOddsType!]!
  getGroupsPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): GroupPaginateType!
  getGroup(id: ID!): GroupType!
  getModerators(groupId: ID!): [UserType!]!
  getMembers(
    groupId: ID!
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): UserPaginateType!
  getGroupsByPrivacy(
    privacy: GroupPrivacyEnum!
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): GroupPaginateType!
  getGroupsSuggestion(
    pagination: PaginationInput = { page: 0, limit: 20 }
    userId: ID!
  ): GroupPaginateType!
  getGroupsByMember(
    memberId: ID!
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): GroupPaginateType!
  getGroupsByModerator(
    moderatorId: ID!
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): GroupPaginateType!
  searchGroups(
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String
  ): GroupPaginateType!
  searchUserGroups(
    userId: ID
    searchString: String
    pagination: PaginationInput = { page: 0, limit: 20 }
    role: GroupRolesEnum!
  ): GroupPaginateType!
  getPackages: [PackageType!]!
  getPackagesBySubscriptionCycle(
    subscriptionCycle: SubscriptionCycleEnum!
  ): [PackageType!]!
  package(id: String!): PackageType!
  getBetOrdersPagination(
    status: BetOrderStatus
    userId: ID
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): BetOrderPaginateType!
  betOrder(id: ID!): BetOrderType!
  getUserPackages: [UserPackageType!]!
  userPackage(id: ID!): UserPackageType!
  getUserPackageByUser(user: ID!): [UserPackageType!]!
  getUserPackageByPackage(package: ID!): [UserPackageType!]!
  getUserPackageByUserAndPackage(package: ID!, user: ID!): UserPackageType!
  getGroupInvitesPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
    groupId: ID!
  ): GroupInvitePaginateType!
  getByModeratorPaginated(
    pagination: PaginationInput = { page: 0, limit: 20 }
    moderatorId: ID!
  ): GroupInvitePaginateType!
  getGroupeInvite(id: String!): GroupInviteType!
  getGroupInvitesByRequestor(
    pagination: PaginationInput = { page: 0, limit: 20 }
    id: ID!
  ): GroupInvitePaginateType!
  searchGroupInvites(
    status: GroupInviteStatusEnum
    requestor: ID
    role: GroupRolesEnum!
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String
  ): GroupInvitePaginateType!
  isMemberOfGroup(memberId: ID!, groupId: ID!): IsMemberOfGroupType!
  getGroupLeaderboardPaginated(
    pagination: PaginationInput = { page: 0, limit: 20 }
    groupId: ID!
  ): GroupLeaderboardPaginatedType!
  getLiveGroupLeaderboardByCyclePaginated(
    pagination: PaginationInput = { page: 0, limit: 20 }
    groupId: ID!
  ): GroupLeaderboardBasePaginatedType!
  searchGroupLeaderboard(
    pagination: PaginationInput = { page: 0, limit: 20 }
    groupId: ID!
    searchString: String
  ): GroupLeaderboardPaginatedType!
  getWalletTransactionersByUserPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
    user: ID!
  ): WalletTransactionPaginateType!
  getWalletTransactionersByUserWithFilterPagination(
    filter: FindWalletTransactionsFilterInput!
    pagination: PaginationInput = { page: 0, limit: 20 }
    user: ID!
  ): WalletTransactionPaginateType!
  getWalletTransaction(id: ID!): WalletTransactionType!
  getMediaOfMessageGroupPagination(
    messageGroup: ID!
    mediaType: MediaTypeEnum!
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): MessageMediaPaginateType!
  getMessagesByMessageGroupPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
    messageGroup: ID!
  ): MessagePaginateType!
  getMessagesByMember(
    target: TargetACIInput!
    type: MessageGroupTypeEnum!
    memberId: ID!
  ): [MessageType!]!
  getMessagesByMemberPaginated(
    pagination: PaginationInput = { page: 0, limit: 20 }
    target: TargetACIInput!
    type: MessageGroupTypeEnum!
    memberId: ID!
  ): MessagePaginateType!
  countUnseenMessages: UnseenMessagesCountType!
  searchMessageByMessageGroupPagination(
    messageGroup: ID!
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String
  ): MessagePaginateType!
  getMessageGroupsPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): MessageGroupPaginateType!
  getDirectMessageGroup(
    target: TargetACIInput!
    receiverId: ID!
  ): MessageGroupType!
  getArchivedMessageGroupsPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): MessageGroupPaginateType!
  getMessageGroup(id: ID!): MessageGroupType!
  searchMessageGroup(
    status: MessageGroupStatusEnum
    target: TargetACIInput
    type: MessageGroupTypeEnum!
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String
  ): MessageGroupPaginateType!
  searchSupportMessageGroup(
    status: MessageGroupStatusEnum
    target: TargetACIInput!
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String
  ): MessageGroupPaginateType!
  searchInternalMessageGroup(
    status: MessageGroupStatusEnum
    target: TargetACIInput!
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String
  ): MessageGroupPaginateType!
  getMessageGroupMembers(
    pagination: PaginationInput = { page: 0, limit: 20 }
    id: ID!
  ): UserPaginateType!
  getMessageGroupByMember(
    target: TargetACIInput
    memberId: ID!
  ): MessageGroupType!
  getWalletsPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): WalletPaginateType!
  getLeaderboardByChallenge(
    pagination: PaginationInput = { page: 0, limit: 20 }
    challenge: ID!
  ): CorporateUserPaginateType!
  wallet(id: String!): WalletDtoType!
  walletByOwner(
    pos: ID
    user: ID
    wholesaler: ID
    manufacturer: ID
  ): WalletDtoType!
  isWalletAndCardInitialized(
    userId: String
  ): IsWalletAndCardInititalizedDtoType!
  getCurrentUserQuantitativeWallet: WalletOnePocketDtoType!
  getCurrentUserQualitativeWallet(
    target: TargetACIInput!
  ): WalletOnePocketDtoType!
  getTargetWallet(target: TargetACIInput!): WalletDtoType!
  getPointOfSalesWithWalletsForModule(
    searchString: String
    pagination: PaginationInput = { page: 0, limit: 20 }
    moduleName: String!
  ): POSWithWalletPaginateType!
  walletOwnerHasEnoughBalance(
    pos: ID
    user: ID
    wholesaler: ID
    manufacturer: ID
    amount: Float!
    usage: PocketUsageType!
  ): WalletOwnerHasEnoughBalanceType!
  getLiveLeaderboardByCyclePaginated(
    input: LeaderboardWithRequiredCycleInput
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): LeaderboardBasePaginatedType!
  getLiveLeaderboardByCycleByExcel(
    path: String
    input: LeaderboardWithRequiredCycleInput
  ): InvoicePDFType!
  sendLiveLeaderboardByCycleBymail(
    input: LeaderboardWithRequiredCycleInput
    subject: String!
    emails: [String!]
  ): MailResponseDto!
  getLeaderboardByCyclePaginated(
    input: LeaderboardWithRequiredCycleInput
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): LeaderboardPaginatedType!
  getLeaderboardDatesByCyclePaginated(
    input: LeaderboardWithOptionalCycleInput
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): EffectiveDatePaginatedType!
  getLeaderboardByDatesAndCyclePaginated(
    input: GetLeaderboardByDatesAndCycleInput
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): LeaderboardPaginatedType!
  getLeaderboard(id: ID!): LeaderboardType!
  getOpeningStatuses: StringListType!
  getSpecialOffersTypes: StringListType!
  getPointOfSalesPagination(
    posCategory: ID
    published: Boolean
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): PointOfSalePaginateType!
  pointOfSale(id: ID!): PointOfSaleType!
  pointOfSaleByOrigin(website: String): PointOfSaleType!
  searchPos(
    published: Boolean
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String
  ): PointOfSalePaginateType!
  findPOSNearbyPagination(
    categoryId: ID
    published: Boolean
    pagination: PaginationInput = { page: 0, limit: 20 }
    rad: Float!
    lat: Float!
    lon: Float!
  ): PointOfSalePaginateType!
  searchPOSNearbyPagination(
    categoryId: ID
    published: Boolean
    searchString: String!
    pagination: PaginationInput = { page: 0, limit: 20 }
    rad: Float!
    lat: Float!
    lon: Float!
  ): PointOfSalePaginateType!
  getPOSWithFollowersPagination(
    published: Boolean
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): PointOfSaleWithFollowShipStatusPaginateType!
  findPOSNearbyWithFollowersPagination(
    categoryId: String
    pagination: PaginationInput = { page: 0, limit: 20 }
    rad: Float!
    lat: Float!
    lon: Float!
  ): PointOfSaleWithFollowShipStatusPaginateType!
  isUserNearPOS(posId: ID!, lat: Float!, lon: Float!): IsUserNearPOSDtoType!
  getCorporateUserCards: [CorporateUserCardType!]!
  corporateUserCard(id: ID!): CorporateUserCardType!
  findCurrentCorporateUserCards: [CorporateUserCardType!]!
  findCurrentCorporateUserCardsByTarget(
    target: TargetACIInput!
  ): [CorporateUserCardType!]!
  corporateUserCardByIdentifier(identifier: String!): CorporateUserCardType!
  getCorporateUserCardsByUser(userId: ID!): [CorporateUserCardType!]!
  getCorporateUserCardsByTarget(
    target: TargetACIInput!
  ): [CorporateUserCardType!]!
  getCorporateUserCardsByTargetPaginated(
    pagination: PaginationInput = { page: 0, limit: 20 }
    cardType: CardTypeEnum
    target: TargetACIInput!
  ): CorporateUserCardFullPaginatedType!
  getCorporateUserCardByUserAndTarget(
    target: TargetACIInput!
    userId: ID!
  ): [CorporateUserCardType!]!
  getWholesalersPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): WholesalerPaginateType!
  getWholesalers: [WholesalerType!]!
  wholesaler(id: String!): WholesalerType!
  searchWholesaler(
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String
  ): WholesalerPaginateType!
  getManufacturersPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): ManufacturerPaginateType!
  manufacturer(id: String!): ManufacturerType!
  searchManufacturer(
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String
  ): ManufacturerPaginateType!
  getModuleDefinitions: [ModulesDefinitionType!]!
  moduleDefinition(id: String!): ModulesDefinitionType!
  findModuleDefinitionsByTarget(
    target: TargetTypeEnum!
  ): [ModulesDefinitionType!]!
  getModulesAssignment: [ModulesAssignmentType!]!
  moduleAssignment(id: String!): ModulesAssignmentType!
  getModuleAssignmentsByAssignee(
    assignee: AssigneeInput!
  ): [ModulesAssignmentType!]!
  findModuleAssignmentsByOrigin: [ModulesAssignmentType!]!
  findModuleAssignmentsforFrame(posId: String!): [ModulesAssignmentType!]!
  getTargetSubscribersPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
    target: TargetACIInput!
    status: [SubscriptionStatus!]!
  ): SubscribersWithReputationsPaginateType!
  searchTargetSubscribers(
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String
    target: TargetACIInput!
    statuses: [SubscriptionStatus!]
  ): SubscribersWithReputationsPaginateType!
  getTargetSubscribersByExcel(
    path: String
    searchString: String
    statuses: [SubscriptionStatus!]
    target: TargetACIInput!
  ): InvoicePDFType!
  sendTargetSubscribersBymail(
    subject: String!
    emails: [String!]
    searchString: String
    statuses: [SubscriptionStatus!]
    target: TargetACIInput
  ): MailResponseDto!
  searchUserTargetSubscriptions(
    statuses: [SubscriptionStatus!]
    target: TargetACIInput!
    searchString: String
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): TargetPaginateType!
  getUserSubscribedTargets(
    statuses: [SubscriptionStatus!]
    userId: String
  ): [TargetType!]!
  getTargetStats(target: TargetACIInput!): StatsType!
  isUserSubscribedToTarget(
    target: TargetACIInput!
  ): IsUserSubscribedToTargetType!
  getAccounts(
    target: TargetACIInput
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): AccountPaginateType!
  getWaitersByPoss(
    pagination: PaginationInput = { page: 0, limit: 20 }
    posId: String!
  ): AccountPaginateType!
  getDeliveryManByPos(
    pagination: PaginationInput = { page: 0, limit: 20 }
    posId: String!
  ): AccountPaginateType!
  getAccountsByTargetAndRoles(
    pagination: PaginationInput = { page: 0, limit: 20 }
    role: [UserRole!]!
    target: TargetACIInput!
  ): AccountPaginateType!
  account(id: String!): AccountType!
  accountByUserId(userId: String!): AccountType!
  currentAccount: AccountType!
  searchAccount(
    target: TargetACIInput!
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String
  ): AccountPaginateType!
  getCompaniesPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): CompanyPaginateType!
  getCompanies: [CompanyType!]!
  company(id: ID!): CompanyType!
  searchCompany(
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String
  ): CompanyPaginateType!
  searchCustomersByTargetAndPhase(
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String
    phase: CustomerPhaseEnum!
    target: TargetACIInput!
  ): CompanyPaginateType!
  searchSuppliersByTarget(
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String
    kinds: [SupplierTypeEnum!]
    target: TargetACIInput!
  ): CompanyPaginateType!
  searchLogisticCompaniesByTarget(
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String
    target: TargetACIInput!
  ): CompanyPaginateType!
  getCustomers(
    pagination: PaginationInput = { page: 0, limit: 20 }
    phase: CustomerPhaseEnum!
    target: TargetACIInput!
  ): CompanyPaginateType!
  getCompaniesByTarget(
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String
    target: TargetACIInput!
  ): CompanyPaginateType!
  getTargetFollowersPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): FollowerPaginateType!
  getFollowedTargetsByUser(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): FollowerPaginateType!
  getFollowersWithFilter(
    pagination: PaginationInput = { page: 0, limit: 20 }
    input: FollowerFilterInput!
  ): FollowerPaginateType!
  getFollowersByTargetPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
    target: TargetACIInput!
  ): FollowerPaginateType!
  isTargetFollowedByUser(target: TargetACIInput!): IsFollowedType!
  searchFollowers(
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String
  ): FollowerPaginateType!
  searchFollowedTargetsByUser(
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String
  ): FollowerPaginateType!
  getFollowedTargets(userId: ID): [TargetWithGroupType!]!
  getFollowedTargetsPaginated(
    userId: ID
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): TargetWithGroupPaginateType!
  getFollowedTargetsWithStoriesPaginated(
    userId: ID
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): TargetWithGroupAndStoriesPaginateType!
  getUsersSuggestions(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): UserPaginateType!
  getGroupsSuggestions(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): GroupPaginateType!
  getTargetFollowers(target: TargetWithGroupInput!): [UserType!]!
  getTargetFollowersPaginated(
    target: TargetWithGroupInput!
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): UserPaginateType!
  isUserFollowingTarget(
    userId: ID
    target: TargetWithGroupInput!
  ): IsFollowingType!
  getStories(filter: StoriesFilterInput!): [StoriesType!]!
  getStoriesByTarget(
    pagination: PaginationInput = { page: 0, limit: 20 }
    target: TargetWithGroupInput!
  ): StoriesPaginatedType!
  getStory(id: ID!): [StoriesType!]!
  getStoriesViewsStatus(
    filter: StoriesViewsStatusFilterInput!
  ): [StoriesViewsStatusType!]!
  getBrandsPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): BrandPaginateType!
  getBrands: [BrandType!]!
  getBrandsByTarget(target: TargetACIInput!): [BrandType!]!
  getBrandsByTargetPaginated(
    pagination: PaginationInput = { page: 0, limit: 20 }
    target: TargetACIInput!
  ): BrandPaginateType!
  brand(id: String!): BrandType!
  searchBrand(
    target: TargetACIInput
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String
  ): BrandPaginateType!
  findBrandByExternalIdAndTarget(
    target: TargetACIInput
    externalId: String!
  ): BrandType!
  getInventoryCategoriesPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): InventoryCategoryPaginateType!
  getInventoryCategories: [InventoryCategoryType!]!
  getInventoryCategoriesByLayerandParent(
    returnEmpty: Boolean
    parent: String
    layer: Int!
  ): [InventoryCategoryType!]!
  getInventoryCategoriesByParent(parent: String!): [InventoryCategoryType!]!
  inventoryCategory(id: String!): InventoryCategoryType!
  searchInventoryCategory(
    layer: Int
    searchString: String
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): InventoryCategoryPaginateType!
  getCatalogueCategoriesByTargetPaginated(
    pagination: PaginationInput = { page: 0, limit: 20 }
    target: TargetACIInput!
  ): CatalogueCategoryPaginateType!
  getCatalogueCategories(target: TargetACIInput!): [CatalogueCategoryType!]!
  getCatalogueCategoriesByTargetForPortal(
    target: TargetACIInput!
  ): [CatalogueCategoryType!]!
  getCatalogueCategoriesByLayerAndParentForPortal(
    parent: String
    target: TargetACIInput!
    layer: Int!
  ): [CatalogueCategoryType!]!
  getCatalogueCategoriesByLayerAndParent(
    parent: String
    variety: ProductVarietyEnum
    target: TargetACIInput!
    layer: Int!
  ): [CatalogueCategoryType!]!
  getCatalogueCategoriesByTargetAndUrlKey(
    urlKey: String
    target: TargetACIInput!
  ): CatalogueCategoryType!
  getCatalogueCategoryPath(id: ID!): [CatalogueCategoryType!]!
  catalogueCategory(id: ID!): CatalogueCategoryType!
  searchCatalogueCategories(
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String
  ): CatalogueCategoryPaginateType!
  getCatalogueCategoriesByTargetWithChildren(
    target: TargetACIInput!
  ): [CatalogueCategoryWithChildrenType!]!
  findCatalogueCategoryByExternalIdAndTarget(
    target: TargetACIInput
    externalId: String!
  ): CatalogueCategoryType!
  getPriceTypes: StringListType!
  getProductsPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): ProductPaginateType!
  getProducts: [ProductType!]!
  getProductsByCategoryPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
    category_ids: [String!]!
  ): ProductPaginateType!
  getProductsByClass(
    pagination: PaginationInput = { page: 0, limit: 20 }
    class: [ProductClassEnum!]!
  ): ProductPaginateType!
  product(id: String!): ProductType!
  findOneByEAN(ean: String!): ProductType!
  searchProduct(
    catId: String
    searchString: String
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): ProductPaginateType!
  getProductWithFilter(
    pagination: PaginationInput = { page: 0, limit: 20 }
    sort: [ProductSortInput!]
    filter: ProductFilterInput
  ): ProductPaginateWithFilterType!
  getAttributesPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): AttributePaginateType!
  getAttributesTargetPaginated(
    pagination: PaginationInput = { page: 0, limit: 20 }
    target: TargetACIInput!
  ): AttributePaginateType!
  getAttributes: [AttributeType!]!
  getAttributesByTarget(target: TargetACIInput!): [AttributeType!]!
  attribute(id: String!): AttributeType!
  searchAttribute(
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String
  ): AttributePaginateType!
  searchAttributeByTarget(
    pagination: PaginationInput = { page: 0, limit: 20 }
    variety: ProductVarietyEnum
    target: TargetACIInput!
    searchString: String
  ): AttributePaginateType!
  findAttributeByExternalIdAndTarget(
    target: TargetACIInput
    externalId: String!
  ): AttributeType!
  getBarcodesPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): BarcodePaginateType!
  getBarcodes: [BarcodeType!]!
  barcode(id: String!): BarcodeType!
  getBarcodeWithStock(id: String!): BarcodeWithStockType!
  getBarcodeByProductAndAttributes(input: BarcodeFindInput!): BarcodeType!
  getProductBarcodes(productId: String!): [BarcodeType!]!
  getProductAttributesPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): ProductAttributePaginateType!
  getProductAttributesByTargetPaginated(
    pagination: PaginationInput = { page: 0, limit: 20 }
    target: TargetACIInput!
  ): ProductAttributePaginateType!
  getProductAttributes: [ProductAttributeType!]!
  getProductAttributesByTarget(
    target: TargetACIInput!
  ): [ProductAttributeType!]!
  getProductAttributesByAttribute(attributId: String!): [ProductAttributeType!]!
  getProductAttributesByAttributeAndTarget(
    target: TargetACIInput!
    attributId: String!
  ): [ProductAttributeType!]!
  productAttribute(id: String!): ProductAttributeType!
  searchProductAttribute(
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String
  ): ProductAttributePaginateType!
  searchProductAttributeByTarget(
    target: TargetACIInput!
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String
  ): ProductAttributePaginateType!
  getInternalProductBarcodes(id: String!): [BarcodeType!]!
  getInternalProductBarcodesPaginated(
    pagination: PaginationInput = { page: 0, limit: 20 }
    id: String!
  ): BarcodePaginateType!
  getBarcodesWithVarietyAndStructureWithFilter(
    pagination: PaginationInput = { page: 0, limit: 20 }
    filter: BarcodeWithVarietyAndStructureFilterInput!
    target: TargetACIInput!
  ): BarcodePaginateType!
  getSimpleProductWithFavoriteStatus(
    # Internal product id
    id: ID!
  ): InternalProductWithFavoriteStatusType!
  getSimpleProductWithFavoriteStatusByUrlKey(
    # Internal product seo urlKey.
    urlKey: String!
    target: TargetACIInput!
  ): InternalProductWithFavoriteStatusType!
  getSimpleProductsByTargetAndCatalogueCategoryUrlKeyWithFavoriteStatus(
    pagination: PaginationInput = { page: 0, limit: 20 }
    target: TargetACIInput!
    urlKey: String!
  ): InternalProductWithFavoriteStatusPaginateType!
  getSimpleProductsByCatalogueCategoryWithFavoriteStatus(
    pagination: PaginationInput = { page: 0, limit: 20 }
    catalogueCategoryIds: [ID!]!
  ): InternalProductWithFavoriteStatusPaginateType!
  getSimpleBarcodeByBarcodeAndTarget(
    target: TargetACIInput!
    barcode: String!
  ): BarcodeType!
  getSimpleProductWithFilter(
    searchString: String
    pagination: PaginationInput = { page: 0, limit: 20 }
    filter: InternalProductFilterInput
    sort: [ProductSortInput!]
  ): InternalProductPaginateWithFilterType!
  searchSimpleEquipments(
    searchInput: SearchSimpleProductInput!
  ): InternalProductPaginateWithFilterType!
  searchSimpleServices(
    searchInput: SearchSimpleProductInput!
  ): BarcodePaginateType!
  getServiceProduct(target: TargetACIInput!): InternalProductType!
  searchSimpleBarcodesByTargetWithStock(
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String
    target: TargetACIInput!
  ): BarcodeWithStockPaginatedType!
  getSimpleServicesWithFilter(
    searchString: String
    pagination: PaginationInput = { page: 0, limit: 20 }
    filter: BarcodesFilterInput
    sort: [ProductSortInput!]
    target: TargetACIInput!
  ): BarcodesPaginatedWithFilterType!
  getSimpleProductsWithRatingsWithFavoriteStatusWithFilter(
    searchString: String
    pagination: PaginationInput = { page: 0, limit: 20 }
    filter: InternalProductFilterInput
    sort: [ProductSortInput!]
  ): InternalProductWithRatingsPaginateWithFavoriteStatusWithFilterType!
  getSimpleBarcodesByBarcodesAndTarget(
    target: TargetACIInput!
    barcodes: [String!]!
  ): [BarcodeType!]!
  getSimpleProductsByTargetGroupedByClassWithFavoriteStatus(
    target: TargetACIInput!
  ): InternalProductByClassTypeWithFavoriteStatus!
  getInternalProducts(
    pagination: PaginationInput = { page: 0, limit: 20 }
    target: TargetACIInput
  ): InternalProductPaginateType!
  findInternalProductByExternalIdAndTarget(
    target: TargetACIInput
    externalId: String!
  ): InternalProductType!
  getAllInternalProducts(target: TargetACIInput): [InternalProductType!]!
  getAllInternalProductsByTargetGroupedByClass(
    target: TargetACIInput!
  ): InternalProductByClassType!
  getAllInternalProductsByTargetGroupedByClassWithFavoriteStatus(
    target: TargetACIInput!
  ): InternalProductByClassTypeWithFavoriteStatus!
  getInternalProductsByCategory(
    pagination: PaginationInput = { page: 0, limit: 20 }
    category: ID!
    target: TargetACIInput!
  ): InternalProductPaginateType!
  getInternalProductsByClass(
    pagination: PaginationInput = { page: 0, limit: 20 }
    class: [ProductClassEnum!]!
    target: TargetACIInput!
  ): InternalProductPaginateType!
  getInternalProductsByTargetAndCatalogueCategoryUrlKey(
    pagination: PaginationInput = { page: 0, limit: 20 }
    target: TargetACIInput!
    urlKey: String!
  ): InternalProductPaginateType!
  getInternalProductsByTargetAndCatalogueCategoryUrlKeyWithFavoriteStatus(
    pagination: PaginationInput = { page: 0, limit: 20 }
    target: TargetACIInput!
    urlKey: String!
  ): InternalProductWithFavoriteStatusPaginateType!
  getOneInternalProductByBarcodeAndTarget(
    target: TargetACIInput!
    barcode: ID!
  ): InternalProductType!
  getInternalProductsByTargetAndCatalogueCategory(
    pagination: PaginationInput = { page: 0, limit: 20 }
    target: TargetACIInput!
    category: ID!
  ): InternalProductPaginateType!
  getInternalProductsByCatalogueCategory(
    pagination: PaginationInput = { page: 0, limit: 20 }
    catalogueCategoryIds: [ID!]!
  ): InternalProductPaginateType!
  getInternalProductsByCatalogueCategoryWithFavoriteStatus(
    pagination: PaginationInput = { page: 0, limit: 20 }
    catalogueCategoryIds: [ID!]!
  ): InternalProductWithFavoriteStatusPaginateType!
  getInternalProductsByCatalogueCategoryForPortal(
    pagination: PaginationInput = { page: 0, limit: 20 }
    catalogueCategoryIds: [ID!]!
  ): InternalProductPaginateType!
  getInternalProductsByProduct(
    pagination: PaginationInput = { page: 0, limit: 20 }
    productId: ID!
  ): InternalProductPaginateType!
  getInternalProduct(id: ID!): InternalProductType!
  getInternalProductWithStock(id: ID!): InternalProductWithStockType!
  getInternalProductWithFavoriteStatus(
    id: ID!
  ): InternalProductWithFavoriteStatusType!
  searchInternalProduct(
    pagination: PaginationInput = { page: 0, limit: 20 }
    searchString: String
  ): InternalProductPaginateType!
  searchInternalProductByCatalogueCategory(
    pagination: PaginationInput = { page: 0, limit: 20 }
    catalogueCategoryId: ID!
    searchString: String
  ): InternalProductPaginateType!
  searchInternalProductByTarget(
    pagination: PaginationInput = { page: 0, limit: 20 }
    target: TargetACIInput!
    searchString: String
  ): InternalProductPaginateType!
  searchBarcodesByTargetAndSupplier(
    pagination: PaginationInput = { page: 0, limit: 20 }
    target: TargetACIInput!
    supplier: ID!
    searchString: String
  ): BarcodePaginateType!
  getBarcodesByTargetPaginated(
    pagination: PaginationInput = { page: 0, limit: 20 }
    target: TargetACIInput!
  ): BarcodePaginateType!
  getBarcodesByTargetWithInternalProductPaginated(
    pagination: PaginationInput = { page: 0, limit: 20 }
    target: TargetACIInput!
    searchString: String
  ): BarcodePaginateType!
  getInternalProductWithFilter(
    searchString: String
    pagination: PaginationInput = { page: 0, limit: 20 }
    filter: InternalProductFilterInput
    sort: [ProductSortInput!]
  ): InternalProductPaginateWithFilterType!
  getInternalProductsWithRatingsWithFilter(
    searchString: String
    pagination: PaginationInput = { page: 0, limit: 20 }
    filter: InternalProductFilterInput
    sort: [ProductSortInput!]
  ): InternalProductWithRatingsPaginateWithFilterType!
  getInternalProductsWithRatingsWithFavoriteStatusWithFilter(
    searchString: String
    pagination: PaginationInput = { page: 0, limit: 20 }
    filter: InternalProductFilterInput
    sort: [ProductSortInput!]
  ): InternalProductWithRatingsPaginateWithFavoriteStatusWithFilterType!
  getBarcodeByBarcodeAndTarget(
    target: TargetACIInput!
    barcode: String!
  ): BarcodeType!
  getBarcodesByBarcodesAndTarget(
    target: TargetACIInput!
    barcodes: [String!]!
  ): [BarcodeType!]!
  getBarcodesWithFilter(
    pagination: PaginationInput = { page: 0, limit: 20 }
    filter: BarcodeFilterInput!
    target: TargetACIInput!
  ): BarcodePaginateType!
  searchBarcodesByTarget(
    pagination: PaginationInput = { page: 0, limit: 20 }
    target: TargetACIInput!
    searchString: String
  ): BarcodePaginateType!
  searchBarcodesByTargetWithStock(
    pagination: PaginationInput = { page: 0, limit: 20 }
    target: TargetACIInput!
    searchString: String
  ): BarcodeWithStockPaginatedType!
  getFavoriteLeagueDefinitionsPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): FavoriteLeagueDefinitionPaginateType!
  favoriteLeagueDefinition(id: ID!): FavoriteLeagueDefinitionType!
  getFavoriteLeaguesPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): FavoriteLeaguePaginateType!
  getFavoriteLeaguesByUserPagination(
    userId: String
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): LeaguePaginateType!
  searchFavouritesLeagues(
    userId: String
    searchString: String
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): LeaguePaginateType!
  favoriteLeague(id: ID!): FavoriteLeagueType!
  isLeagueFavorite(leagueId: Int!, userId: String!): BooleanCheckType!
  getFavoriteTeamsPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): FavoriteTeamPaginateType!
  getFavoriteTeamsByUserPagination(
    userId: String
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): TeamInformationPaginateType!
  searchFavouritesTeams(
    userId: String
    searchString: String
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): TeamInformationPaginateType!
  favoriteTeam(id: ID!): FavoriteTeamType!
  isTeamFavorite(teamId: Int!, userId: String!): BooleanCheckType!
  getFavoriteTeamDefinitionsPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): FavoriteTeamDefinitionPaginateType!
  favoriteTeamDefinition(id: ID!): FavoriteTeamDefinitionType!
  getFixturesForPreOdds(date: DateTime!): [FixtureType!]!
  createOrUpdatePlayFixtures(date: DateTime!): PlayFixturesType!
  createOrUpdateLeaguesWithFixtures(date: DateTime!): [DateFixturesType!]!
  getLeaguesWithFixtures(
    pagination: PaginationInput = { page: 0, limit: 20 }
    date: DateTime!
  ): LeagueWithFixturesPaginatedType!
  getLeaguesByDateAndUserFavoriteLeagues(
    userId: String
    pagination: PaginationInput = { page: 0, limit: 20 }
    date: DateTime!
  ): LeagueWithFixturesPaginatedType!
  getLiveLeaguesByDateAndUserFavoriteLeagues(
    userId: String
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): LeagueWithFixturesPaginatedType!
  findCounteryById(id: ID!): CountryType!
  findCountriesPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): CountryPaginatedType!
  findStateById(id: ID!): StateType!
  getStates: [StateType!]!
  findStatesPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): StatePaginatedType!
  findStatesByCountryPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
    country: ID!
  ): StatePaginatedType!
  findLanguageById(id: ID!): LanguageType!
  getLanguages: [LanguageType!]!
  findlanguagesPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): LanguagePaginatedType!
  findSocialById(id: ID!): SocialType!
  findSocialByCode(code: String!): SocialType!
  findSocialsPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): SocialPaginatedType!
  findPaymentById(id: ID!): PaymentType!
  findPaymentsPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): PaymentPaginatedType!
  findPayments: [PaymentType!]!
  findBrowserById(id: ID!): BrowserType!
  findBrowsersPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): BrowserPaginatedType!
  findTechDeviceById(id: ID!): TechDeviceType!
  findTechDevicesPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): TechDevicePaginatedType!
  findTechDeviceBrandById(id: ID!): TechDeviceBrandType!
  findTechDeviceBrandsPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): TechDeviceBrandPaginatedType!
  findDeviceTypeById(id: ID!): TechDeviceTypeType!
  findDeviceTypesPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): TechDeviceTypePaginatedType!
  findOperatingSystemById(id: ID!): OperatingSystemType!
  findOperatingSystemsPagination(
    pagination: PaginationInput = { page: 0, limit: 20 }
  ): OperatingSystemPaginatedType!
  sendEmail(input: EmailTempInput!): MailResponseDto!
  getEmailTemplate: [EmailTemplateType!]!
  emailTemplate(id: ID!): EmailTemplateType!
  findEmailTemplateByName(name: EmailTemplateTypeEnum!): EmailTemplateType!
}

input LoginInput {
  # Login email or username.
  login: String
  phone: IPhoneInput
  password: String!
}

input IPhoneInput {
  # Phone number
  number: String

  # Phone country code
  countryCode: String
}

input AuthorizationDataInput {
  email: String
  state: String
  givenName: String
  familyName: String
  identityToken: String!
  userIdentifier: String
  authorizationCode: String
}

input PaginationInput {
  page: Int = 0
  limit: Int = 20
}

input IsLoginExistInput {
  # Login email or username.
  login: String
  phone: IPhoneInput
}

input PictureInput {
  width: Int
  height: Int
  x: Int
  y: Int
  alt: String
  baseUrl: String!
  path: String!
}

input CountryProviderInput {
  name: [String!]
  code: [String!]
}

input LeagueFilterInput {
  id: [Int!]
  team: [Int!]
  season: [Int!]
  name: [String!]
  code: [String!]
  country: [String!]
  current: Boolean
  type: [LeagueTypeEnum!]
}

input TeamInformationFilterInput {
  id: [Int!]
  name: [String!]
  country: [String!]
}

input FixtureFilterInput {
  id: [Int!]
  league: [Int!]
  season: [Int!]
  team: [Int!]
  timezone: String
  status: [FixtureStatusEnum!]
  from: DateTime
  to: DateTime
}

enum FixtureStatusEnum {
  HT
  WO
  ET
  NS
  FT
  LIVE
  AWD
  P
  PST
  ABD
  SUSP
  CANC
  INT
  TBD
  BT
  PEN
  AET
}

enum RoundsEnum {
  ROUND_16
  QUARTER_FINAL
  SEMI_FINAL
  THIRD_PLACE
  FINAL
}

input TargetACIInput {
  # pos id
  pos: String

  # wholesaler id
  wholesaler: String

  # manufacturer id
  manufacturer: String

  # Commercial id
  user: String
}

input InjuriesFilterInput {
  fixture: [Int!]
  league: [Int!]
  season: [Int!]
  team: [Int!]
  player: [Int!]
  timezone: String
}

input PlayersStatsFilterInput {
  teams: [Int!]
  seasons: [Int!]
  leagues: [Int!]
  search: String
}

input OddsFilterInput {
  fixture: Int
  league: Int
  season: Int
  bet: [Int!]
  bookmakers: [Int!]
  timezone: String
  date: DateTime
}

enum GroupRolesEnum {
  MEMBER
  MODERATOR
}

input FindWalletTransactionsFilterInput {
  pocketTypes: [PocketTypeEnum!]
  transactionTypes: [WalletTransactionTypeEnum!]
  transactionReasons: [WalletTransactionReasonEnum!]
}

enum MediaTypeEnum {
  VIDEO
  PICTURE
}

input LeaderboardWithRequiredCycleInput {
  cycle: LeaderboardCycleEnum!
  target: TargetACIInput
  searchString: String
}

input LeaderboardWithOptionalCycleInput {
  cycle: LeaderboardCycleEnum
  target: TargetACIInput
  searchString: String
}

input GetLeaderboardByDatesAndCycleInput {
  cycle: LeaderboardCycleEnum!
  target: TargetACIInput
  searchString: String
  end: String!
  start: String!
}

input AssigneeInput {
  user: String
  pos: String
  wholesaler: String
  manufacturer: String
}

input FollowerFilterInput {
  user: [String!]
  pos: [Float!]
  from: DateTime
  to: DateTime
}

input TargetWithGroupInput {
  # pos id
  pos: ID

  # User id
  user: ID

  # Group id
  group: ID

  # wholesaler id
  wholesaler: ID

  # manufacturer id
  manufacturer: ID
}

input StoriesFilterInput {
  forConsumer: Boolean = false

  # User id
  user: ID

  # Pos id
  pos: ID

  # wholesaler id
  wholesaler: ID

  # Manufacturer id
  manufacturer: ID

  # Group id
  group: ID
}

input StoriesViewsStatusFilterInput {
  # User id
  user: [String!]

  # Pos id
  pos: [String!]

  # wholesaler id
  wholesaler: [String!]

  # manufacturer id
  manufacturer: [String!]

  # Group id
  group: ID
}

input ProductSortInput {
  # 1 for sort by createdAt ascending and -1 for descending
  createdAt: Float

  # 1 for sort by updatedAt ascending and -1 for descending
  updatedAt: Float

  # 1 for sort by name ascending and -1 for descending
  name: Float

  # 1 for sort by price ascending and -1 for descending
  price: Float
}

input ProductFilterInput {
  fromPrice: String
  toPrice: String
  from: DateTime
  to: DateTime

  # list of productAttributes ids
  productAttributes: [String!]

  # list of barcodes ids
  barcodes: [ID!]

  # list of brands ids
  brand: [String!]

  # list of inventoryCategories ids
  category: [String!]
  class: [ProductClassEnum!]
  structure: [ProductStructureEnum!]
  variety: [ProductVarietyEnum!]
  rent: Boolean
}

input BarcodeFindInput {
  product: ID
  internalProduct: ID
  productAttributesValues: [ID!]
}

input BarcodeWithVarietyAndStructureFilterInput {
  barcode: [String!]
  status: [ProductStatusEnum!]
  condition: [ProductConditionEnum!]
  structure: [ProductStructureEnum!]
  variety: [ProductVarietyEnum!]
  searchString: String
}

input InternalProductFilterInput {
  fromPrice: String
  toPrice: String
  from: DateTime
  to: DateTime

  # list of brands ids
  brand: [ID!]

  # list of inventoryCategories ids
  category: [ID!]
  target: TargetsInput
  attributesValues: [ID!]

  # list of catalogueCategories ids
  catalogueCategory: [ID!]

  # list of internalProduct classes
  class: [ProductClassEnum!]
  condition: [ProductConditionEnum!]
  status: [ProductStatusEnum!]
  structure: [ProductStructureEnum!]
  variety: [ProductVarietyEnum!]
  rent: Boolean
}

input TargetsInput {
  # list of pointOfSales ids
  pos: [ID!]

  # list of wholesalers ids
  wholesaler: [ID!]

  # list of manufacturers ids
  manufacturer: [ID!]
}

input SearchSimpleProductInput {
  target: TargetACIInput
  searchString: String
  status: [ProductStatusEnum!]
  pagination: PaginationInput = { page: 0, limit: 20 }
}

input BarcodesFilterInput {
  fromPrice: String
  toPrice: String
  from: DateTime
  to: DateTime

  # list of catalogueCategories ids
  catalogueCategory: [ID!]
}

input BarcodeFilterInput {
  barcode: [String!]
  status: [ProductStatusEnum!]
  condition: [ProductConditionEnum!]
}

input EmailTempInput {
  to: [String!]!
  subject: String!
  template: EmailTemplateTypeEnum
  content: EmailContentInput
  variables: EmailTempVariablesInput
  attachments: [MailAttachmentInput!]
}

input EmailContentInput {
  base64: String
  path: String
}

input EmailTempVariablesInput {
  brand: EmailTempVariablesBrandInput
  user: EmailTempVariablesUserInput
  company: EmailTempVariablesCompanyInput
  actionUrl: String
  document: EmailTempVariablesDocumentInput
  variables: [String!]
}

input EmailTempVariablesBrandInput {
  logo: String
  website: String
  name: String
}

input EmailTempVariablesUserInput {
  firstName: String
  lastName: String
  email: String
}

input EmailTempVariablesCompanyInput {
  name: String
  website: String
  phone: String
  address: String
}

input EmailTempVariablesDocumentInput {
  category: SequenceCategoryEnum!
  id: ID!
  name: String!
}

enum SequenceCategoryEnum {
  QUOTATION
  SALE_ORDER
  SALE_INVOICE
  SALE_DELIVERY_NOTE
  SALE_ISSUE_NOTE
  PURCHASE_INVOICE
  PURCHASE_DELIVERY_NOTE
  PURCHASE_ORDER
}

input MailAttachmentInput {
  filename: String!
  content: String!
  encoding: String!
}

type Mutation {
  register(
    brand: EmailTempVariablesBrandInput!
    subject: String!
    input: UserInput!
  ): LoginType!
  registerForApp(
    brand: EmailTempVariablesBrandInput!
    subject: String!
    input: UserInput!
  ): LoginType!
  updateVapidKey(input: VapidKeyInput!): VapidKeyType!
  createUser(
    variables: EmailTempVariablesInput
    subject: String!
    input: UserInput!
  ): UserType!
  createUserForApp(
    variables: EmailTempVariablesInput
    input: UserInput!
    subject: String!
  ): UserType!
  updateUser(input: UserUpdateInput!, id: ID!): UserType!
  updateCurrentUser(input: UserUpdateInput!): UserType!
  updateCurrentUserPassword(
    newPassword: String!
    oldPassword: String!
  ): UserType!
  updateCurrentUserPasswordForApp(
    newPassword: String!
    oldPassword: String!
  ): UserType!
  updateCurrentUserEmail(email: String!): LoginType!
  updateCurrentUserLogins(
    email: String
    username: String
    phone: IPhoneInput
  ): LoginType!
  updateUserPasswordForApp(newPassword: String!, id: ID!): UserType!
  updateCurrentUserApp(app: App!): UserType!
  updateUserApp(app: App!, id: String!): UserType!
  sendForgotPasswordMail(
    brand: EmailTempVariablesBrandInput
    subject: String!
    email: String!
  ): MailResponseDto!
  resetPassword(password: String!, token: String!): UserType!
  resetPasswordWithMailForApp(input: ResetPasswordForAppInput!): UserType!
  sendValidMail(
    subject: String!
    variables: EmailTempVariablesInput
  ): MailResponseDto!
  sendMergeAccountsEmail(
    app: App!
    ooredooId: String!
    email: String!
  ): MailResponseDto!
  validateMail(token: String!): UserType!
  validatePhoneNumber(smsNumber: Int!): UserType!
  processWelcomeMail(password: String, token: String!): UserType!
  mergeAccounts(token: String!): UserType!
  deleteUser(
    description: String
    reason: DeleteUserReasonEnum!
    id: ID!
    password: String!
  ): DeleteResponseDtoType!
  saveCurrentUserStatus(status: UserStatus!): UserType!
  insertOrigin(url: String!): OriginType!
  createNewVersion(input: NewVersionInput!): VersionType!
  updateVersion(input: UpdateVersionInput!): VersionType!
  markAllAsSeenForUser: NotificationResponse!
  markAllAsSeenForPOS(posId: String!): NotificationResponse!
  createAdhocNotification(
    executedAt: DateTime
    picture: PictureInput!
    description: String!
    title: String!
  ): NotificationFullType!
  getFixtureSubscribers(fixtureId: ID!): UserType!
  addUserToEventSubscription(fixture: ID!, user: ID): EventSubscriptionType!
  removeUserFromEventSubscription(
    fixture: ID!
    user: ID
  ): DeleteResponseDtoType!
  sendRegistrationValidationSms(
    app: App!
    phone: IPhoneInput!
  ): SmsIntegrationType!
  sendValidSms(app: App!): SmsIntegrationType!
  resetPasswordWithSmsForApp(input: ResetPasswordForAppInput!): UserType!
  createGroup(input: GroupInput!): GroupType!
  addMember(memberId: ID, id: ID!): GroupType!
  addModerator(moderatorId: ID!, id: ID!): GroupType!
  removeMember(memberId: ID!, id: ID!): GroupType!
  removeModerator(moderatorId: ID!, id: ID!): GroupType!
  updateGroup(input: GroupUpdateInput!): GroupType!
  createPackage(
    name: String!
    color: String
    description: String
    perks: [String!]
    price: String!
    delivrable: String!
    subscriptionCycle: SubscriptionCycleEnum!
  ): PackageType!
  updatePackage(
    name: String
    color: String
    description: String
    perks: [String!]
    price: String
    delivrable: String
    subscriptionCycle: SubscriptionCycleEnum
    id: ID!
  ): PackageType!
  deletePackage(id: ID!): DeleteResponseDtoType!
  placeBet(input: BetOrderInput!): BetOrderType!
  createUserPackage(
    user: ID!
    package: ID!
    expiresIn: DateTime!
    autoRenew: Boolean!
  ): UserPackageType!
  updateUserPackage(
    user: ID
    package: ID
    expiresIn: DateTime
    autoRenew: Boolean
    id: ID!
  ): UserPackageType!
  deleteUserPackage(id: ID!): DeleteResponseDtoType!
  requestJoinGroup(groupId: ID!, userId: ID!): GroupInviteType!
  replyToGroupRequest(status: GroupInviteStatusEnum!, id: ID!): GroupInviteType!
  cancelJoinGroup(userId: ID!, groupId: ID!): GroupInviteType!
  createMessage(input: MessageInput!): MessageType!
  createDirectMessage(input: DirectMessageInput!): MessageType!
  sendMessageToTarget(input: SendMessageToTargetInput!): MessageType!
  markMessageAsSeen(id: ID!): MessageType!
  markAllMessageAsSeen(
    # message group Id.
    messageGroup: ID!
  ): DeleteResponseDtoType!
  markAllMessagesAsSeenForTarget(
    # message group Id.
    messageGroup: ID!
    target: TargetACIInput
  ): DeleteResponseDtoType!
  createMessageGroup(input: MessageGroupInput): MessageGroupType!
  archiveMessageGroup(id: ID!): MessageGroupType!
  unarchiveMessageGroup(id: ID!): MessageGroupType!
  muteMessageGroup(id: ID!): MessageGroupType!
  unmuteMessageGroup(id: ID!): MessageGroupType!
  addMemeberToMessageGroup(user: [ID!]!, id: ID!): MessageGroupType!
  removeMemberFromMessageGroup(user: [ID!]!, id: ID!): MessageGroupType!
  updateMessageGroup(input: MessageGroupUpdateInput!): MessageGroupType!
  initQualitativeWallet(target: TargetACIInput!, user: String!): WalletDtoType!
  initTargetWallet(target: TargetACIInput!): WalletDtoType!
  initUserWallet: WalletDtoType!
  addUserWallet: WalletDtoType!
  increaseAmount(
    id: ID!
    amount: String!
    usage: PocketUsageType!
    pocketType: PocketTypeEnum!
    challenge: ID
    target: TargetACIInput
  ): WalletDtoType!
  deductAmount(
    id: ID!
    amount: String!
    usage: PocketUsageType!
    pocketType: PocketTypeEnum!
    challenge: ID
    target: TargetACIInput
  ): WalletDtoType!
  performTransaction(input: PerformTransactionInput!): DeleteResponseDtoType!
  createPointOfSale(input: PointOfSaleInput!): PointOfSaleType!
  updatePointOfSale(input: PointOfSaleInput!, id: ID!): PointOfSaleType!
  deletePointOfSale(id: ID!): PointOfSaleType!
  generateCorporateUserCard(
    cardTypes: [CardTypeEnum!]
    target: TargetACIInput
    user: ID!
  ): GenerateUserCardType!
  updateCorporateUserCard(
    validUntil: DateTime!
    id: ID!
  ): CorporateUserCardType!
  expireCorporateUserCard(id: ID!): DeleteResponseDtoType!
  createWholesaler(input: WholesalerCreateInput!): WholesalerType!
  updateWholesaler(input: WholesalerUpdateInput!): WholesalerType!
  deleteWholesaler(id: String!): WholesalerType!
  createManufacturer(input: ManufacturerCreateInput!): ManufacturerType!
  updateManufacturer(input: ManufacturerUpdateInput!): ManufacturerType!
  deleteManufacturer(id: String!): ManufacturerType!
  createModuleDefinition(input: ModulesDefinitionInput!): ModulesDefinitionType!
  updateModuleDefinition(
    input: ModulesDefinitionInput!
    id: String!
  ): ModulesDefinitionType!
  deleteModuleDefinition(id: ID!): ModulesDefinitionType!
  createModuleAssignment(input: ModulesAssignmentInput!): ModulesAssignmentType!
  updateModuleAssignment(
    input: ModulesAssignmentInput!
    id: String!
  ): ModulesAssignmentType!
  deleteModuleAssignment(id: String!): ModulesAssignmentType!
  requestSubscription(input: SubscribersInput!): SubscribersFullType!
  subscribeUserToTarget(
    target: TargetACIInput!
    user: String!
  ): SubscribersFullType!
  approveSubscription(
    # Subscription id.
    id: ID!
  ): SubscribersFullType!
  rejectSubscription(
    # Subscription id.
    id: ID!
  ): SubscribersFullType!
  cancelSubscription(userId: ID!, target: TargetACIInput!): SubscribersFullType!
  deleteSubscriber(
    # Subscription id.
    id: ID!
  ): DeleteResponseDtoType!
  createAccount(input: AccountInput!): AccountType!
  addTargetsToAccount(
    targets: TargetsInput!
    roles: [UserPOSRoleEnum!]!
    userId: String!
  ): AccountType!
  updateAccount(expiresAt: DateTime!, accountId: String!): AccountType!
  updateAccountByAdmin(
    input: AccountUpdateInput!
    accountId: String!
  ): AccountType!
  deleteAccount(accountId: String!): DeleteResponseDtoType!
  createCompany(input: CompanyInput!): CompanyType!
  updateCompany(input: CompanyUpdateInput!, id: ID!): CompanyType!
  bulkUpdateCompanyMedia(input: [UpdateMediaInput!]!): [CompanyType!]!
  deleteCompany(id: ID!): DeleteResponseDtoType!
  createFollower(input: FollowerInput!): FollowerType!
  unfollowTarget(target: TargetWithGroupInput!): DeleteResponseDtoType!
  followTarget(target: TargetWithGroupInput!): FollowType!
  insertStory(input: StoriesInput!): StoriesType!
  markStoryAsSeen(id: ID!): StoriesType!
  deleteStory(id: ID!): DeleteResponseDtoType!
  createBrand(input: BrandInput!): BrandType!
  syncOneBrand(input: BrandInput!): BrandType!
  updateBrand(input: BrandInput!, id: String!): BrandType!
  deleteBrand(id: String!): DeleteResponseDtoType!
  createInventoryCategory(
    input: InventoryCategoryInput!
  ): InventoryCategoryType!
  updateInventoryCategory(
    input: InventoryCategoryInput!
    id: String!
  ): InventoryCategoryType!
  deleteInventoryCategory(id: String!): InventoryCategoryType!
  createCatalogueCategory(
    input: CatalogueCategoryInput!
  ): CatalogueCategoryType!
  reorderCatalogueCategories(
    target: TargetACIInput!
    catalogCategoryId: String!
    newRank: Float!
  ): [CatalogueCategoryType!]!
  syncOneCategory(input: CatalogueCategoryBulkInput!): CatalogueCategoryType!
  updateCatalogueCategory(
    input: CatalogueCategoryUpdateInput!
  ): CatalogueCategoryType!
  deleteCatalogueCategory(id: ID!): DeleteResponseDtoType!
  createProduct(input: ProductInput!): ProductType!
  updateProduct(input: ProductUpdateInput!, id: String!): ProductType!
  deleteProduct(id: String!): ProductType!
  createAttribute(input: AttributeCreateInput!): AttributeType!
  updateAttribute(input: AttributeUpdateInput!): AttributeType!
  syncOneAttribute(input: AttributeCreateInput!): AttributeType!
  deleteAttribute(id: String!): DeleteResponseDtoType!
  updateBarcode(input: BarcodeUpdateInput!): BarcodeType!
  bulkUpdateBarcodeMedia(input: [UpdateMediaInput!]!): [BarcodeType!]!
  createProductAttribute(input: ProductAttributeInput!): ProductAttributeType!
  updateProductAttribute(
    input: ProductAttributeUpdateInput!
  ): ProductAttributeType!
  deleteProductAttribute(id: String!): DeleteResponseDtoType!
  createServiceProduct(
    target: TargetACIInput
    input: BarcodeInput!
  ): BarcodeType!
  createSimpleProduct(input: CreateSimpleProductInput!): InternalProductType!
  updateSimpleProduct(input: UpdateSimpleProductInput!): InternalProductType!
  createInternalProduct(
    input: CreateInternalProductInput!
  ): InternalProductType!
  createCustomInternalProduct(
    input: CreateCustomInternalProductInput!
  ): InternalProductType!
  createInternalProductAndProduct(
    externalId: String
    tags: [String!]
    discount: DiscountDtoInput
    internalProductAttributes: InternalProductAttributeInput

    # list of barcodes ids
    barcodes: [ID!]

    # list of suppliers ids
    suppliers: [ID!]
    price: String
    target: TargetACIInput!
    catalogueCategory: [ID!]!
    globalCategory: GlobalCategoryInput
    name: String!
    sku: String
    condition: ProductConditionEnum
    status: ProductStatusEnum
    description: String
    descriptionList: [String!]
    specs: [ProductSpecsInput!]
    picture: PictureInput
    pictures: [PictureInput!]
    media: MediaInput
    ean: String
    weight: Int
    class: [ProductClassEnum!]
    wholesalerPrice: String
    factoryPrice: String
    tax: String!
    structure: ProductStructureEnum
    brand: ID
    category: [ID!]
  ): InternalProductType!
  updateInternalProductAndProduct(
    externalId: String
    tags: [String!]
    discount: DiscountDtoInput
    internalProductAttributes: InternalProductAttributeInput

    # list of barcodes ids
    barcodes: [ID!]

    # list of suppliers ids
    suppliers: [ID!]
    price: String
    catalogueCategory: [ID!]
    globalCategory: GlobalCategoryInput
    name: String
    sku: String
    condition: ProductConditionEnum
    status: ProductStatusEnum
    description: String
    descriptionList: [String!]
    specs: [ProductSpecsInput!]
    picture: PictureInput
    pictures: [PictureInput!]
    media: MediaInput
    ean: String
    weight: Int
    class: [ProductClassEnum!]
    wholesalerPrice: String
    factoryPrice: String
    tax: String
    structure: ProductStructureEnum
    brand: ID
    category: [ID!]
    id: ID!
  ): InternalProductType!
  updateInternalProduct(
    input: UpdateInternalProductInput!
  ): InternalProductType!
  addBarcodeToInternalProductAndProduct(
    barcodeId: ID!
    productId: ID!
    id: ID!
  ): InternalProductType!
  deleteInternalProduct(id: ID!): DeleteResponseDtoType!
  createBarcode(target: TargetACIInput, input: BarcodeInput!): BarcodeType!
  createBarcodeForTarget(
    target: TargetACIInput
    input: BarcodeInput!
  ): BarcodeType!
  deleteBarcode(id: String!): DeleteResponseDtoType!
  createFavoriteLeagueDefinition(league: String!): FavoriteLeagueDefinitionType!
  deleteFavoriteLeagueDefinition(id: String!): FavoriteLeagueDefinitionType!
  createFavoriteLeagues(input: FavoriteLeagueInput!): FavoriteLeagueType!
  initFavoriteLeagues(userId: String): DeleteResponseDtoType!
  updateFavoriteLeagues(
    input: FavoriteLeagueInput!
    id: String!
  ): FavoriteLeagueType!
  deleteFavoriteLeagues(leagueId: Int!): DeleteResponseDtoType!
  createFavoriteTeams(input: FavoriteTeamInput!): FavoriteTeamType!
  deleteFavoriteTeams(teamId: Int!): DeleteResponseDtoType!
  createFavoriteTeamDefinition(team: ID!): FavoriteTeamDefinitionType!
  deleteFavoriteTeamDefinition(id: String!): FavoriteTeamDefinitionType!
  createCountry(input: CountryInput!): CountryType!
  updateCountry(input: CountryInput!, id: ID!): CountryType!
  deleteCountry(id: ID!): DeleteResponseDtoType!
  createState(input: StateInput!): StateType!
  updateState(input: StateInput!, id: ID!): StateType!
  deleteState(id: ID!): DeleteResponseDtoType!
  createLanguage(input: LanguageInput!): LanguageType!
  updateLanguage(input: LanguageInput!, id: ID!): LanguageType!
  deleteLanguage(id: ID!): DeleteResponseDtoType!
  createSocial(input: SocialInput!): SocialType!
  updateSocial(input: SocialInput!, id: ID!): SocialType!
  deleteSocial(id: ID!): DeleteResponseDtoType!
  createPayment(input: PaymentInput!): PaymentType!
  updatePayment(input: PaymentInput!, id: ID!): PaymentType!
  deletePayment(id: ID!): DeleteResponseDtoType!
  createBrowser(input: BrowserInput!): BrowserType!
  updateBrowser(input: BrowserInput!, id: ID!): BrowserType!
  deleteBrowser(id: ID!): DeleteResponseDtoType!
  createTechDevice(input: TechDeviceInput!): TechDeviceType!
  updateTechDevice(input: TechDeviceInput!, id: ID!): TechDeviceType!
  deleteTechDevice(id: ID!): DeleteResponseDtoType!
  createTechDeviceBrand(input: TechDeviceBrandInput!): TechDeviceBrandType!
  updateTechDeviceBrand(
    input: TechDeviceBrandInput!
    id: ID!
  ): TechDeviceBrandType!
  deleteTechDeviceBrand(id: ID!): DeleteResponseDtoType!
  createTechDeviceType(input: TechDeviceTypeInput!): TechDeviceTypeType!
  updateTechDeviceType(
    input: TechDeviceTypeInput!
    id: ID!
  ): TechDeviceTypeType!
  deleteTechDeviceType(id: ID!): DeleteResponseDtoType!
  createOperatingSystem(input: OperatingSystemInput!): OperatingSystemType!
  updateOperatingSystem(
    input: OperatingSystemInput!
    id: ID!
  ): OperatingSystemType!
  deleteOperatingSystem(id: ID!): DeleteResponseDtoType!
  createEmailTemplate(input: EmailTemplateInput!): EmailTemplateType!
  updateEmailTemplate(input: EmailTemplateInput!, id: ID!): EmailTemplateType!
  deleteEmailTemplate(id: ID!): DeleteResponseDtoType!
}

input UserInput {
  email: String
  username: String
  phone: IPhoneInput
  password: String!
  picture: PictureInput
  pictures: [PictureInput!]
  covers: [PictureInput!]
  firstName: String
  status: UserStatus
  title: String
  about: String
  lastName: String
  maritalStatus: MaritalStatus
  gender: Gender
  languages: [String!]
  education: [UserEducationInput!]
  work: [UserWorkInput!]
  lived: [ID!]
  hobbies: [String!]
  interests: [String!]
  isMailValid: Boolean
  plugged: Boolean
  dateOfBirth: DateTime
  chatContact: [SocialValueInput!]
  socialMedia: [SocialValueInput!]
  nationality: String
  locale: String
  placeOfBirth: String
  residentialAddress: [FullAddressInput!]
  shippingAddress: [FullAddressInput!]
  billingAddress: [FullAddressInput!]
  mobileTheme: MobileThemesEnum
  source: SourcesEnum
  newsletterSubs: Boolean
  roles: [UserRole!]!
  apps: [App!]
  phoneNumber: String
}

input UserEducationInput {
  level: AcademicLevel
  name: String
  description: String
  tags: [String!]
  from: DateTime
  to: DateTime
  graduated: Boolean
}

input UserWorkInput {
  company: String
  position: String
  description: String
  city: ID
  tags: [String!]
  from: DateTime
  to: DateTime
  current: Boolean
}

input SocialValueInput {
  name: ID!
  value: String!
}

input FullAddressInput {
  owner: FullAddressOwnerInput
  address: String
  postCode: String
  city: String
  country: ID
  state: ID
  addressLine: String
  location: LonLatInput
}

input FullAddressOwnerInput {
  name: String
  phone: FullAddressOwnerPhoneInput
}

input FullAddressOwnerPhoneInput {
  number: String
  countryCode: String
}

input LonLatInput {
  type: String!
  coordinates: [Float!]!
}

input VapidKeyInput {
  vapidKey: String!
  userId: String!
}

input UserUpdateInput {
  password: String
  picture: PictureInput
  pictures: [PictureInput!]
  covers: [PictureInput!]
  firstName: String
  status: UserStatus
  title: String
  about: String
  lastName: String
  maritalStatus: MaritalStatus
  gender: Gender
  languages: [String!]
  education: [UserEducationInput!]
  work: [UserWorkInput!]
  lived: [ID!]
  hobbies: [String!]
  interests: [String!]
  isMailValid: Boolean
  plugged: Boolean
  dateOfBirth: DateTime
  chatContact: [SocialValueInput!]
  socialMedia: [SocialValueInput!]
  nationality: String
  locale: String
  placeOfBirth: String
  residentialAddress: [FullAddressInput!]
  shippingAddress: [FullAddressInput!]
  billingAddress: [FullAddressInput!]
  mobileTheme: MobileThemesEnum
  source: SourcesEnum
  newsletterSubs: Boolean
  roles: [UserRole!]
  apps: [App!]
  phoneNumber: String
  email: String
  username: String
  phone: IPhoneInput
  vapidKey: String
}

input ResetPasswordForAppInput {
  password: String!
  token: String
  smsValidationCode: Int
  phone: IPhoneInput
}

enum DeleteUserReasonEnum {
  LACK_OF_CONTENT
  SOMETHING_IS_BROKEN
  SIZE_AND_COMPATIBILITY
}

input NewVersionInput {
  platform: PlatformEnum
  requireUpdate: Boolean
  versionContent: [VersionContentInput!]
  version: String!
}

input VersionContentInput {
  contentType: VersionContentTypeEnum
  content: String
}

input UpdateVersionInput {
  platform: PlatformEnum
  requireUpdate: Boolean
  versionContent: [VersionContentInput!]
  id: ID!
  version: String
}

input GroupInput {
  name: String!
  description: String
  isVerified: Boolean
  picture: NestedPicturesInput
  privacy: GroupPrivacyEnum
  members: [ID!]
  moderators: [ID!]
}

input NestedPicturesInput {
  cover: PictureInput
  profile: PictureInput
}

input GroupUpdateInput {
  name: String
  description: String
  isVerified: Boolean
  picture: NestedPicturesInput
  privacy: GroupPrivacyEnum
  id: ID!
}

input BetOrderInput {
  bet: Int!
  status: BetOrderStatus
  odds: [BetOrderOddsInput!]!
}

input BetOrderOddsInput {
  fixture: ID!
  odds: [BetOrderOddsOddsInput!]!
}

input BetOrderOddsOddsInput {
  extId: Int!
  name: String!
  value: String!
  odd: String!
}

input MessageInput {
  text: String
  gif: String
  sticker: String
  custom: CustomMessageInput
  media: MessageMediaInput
  location: LonLatInput
  messageGroup: ID!
  seenBy: [ID!]
}

input CustomMessageInput {
  id: String
  type: String
}

input MessageMediaInput {
  picture: [PictureInput!]
  video: [PictureInput!]
}

input DirectMessageInput {
  text: String
  gif: String
  sticker: String
  custom: CustomMessageInput
  media: MessageMediaInput
  location: LonLatInput
  seenBy: [ID!]
  receiver: ID!
  target: TargetACIInput
  type: MessageGroupTypeEnum
}

input SendMessageToTargetInput {
  text: String
  gif: String
  sticker: String
  custom: CustomMessageInput
  media: MessageMediaInput
  location: LonLatInput
  seenBy: [ID!]
  target: TargetACIInput!
}

input MessageGroupInput {
  name: String
  mute: Boolean
  creator: String
  profilePicture: PictureInput
  wallpaper: MessageGroupWallpaperInput
  sound: MessageSoundEnum
  status: MessageGroupStatusEnum
  target: TargetACIInput
  type: MessageGroupTypeEnum
  members: [String!]
}

input MessageGroupWallpaperInput {
  picture: PictureInput
  gradientColors: [String!]
  assetImage: String
}

input MessageGroupUpdateInput {
  name: String
  creator: String
  profilePicture: PictureInput
  wallpaper: MessageGroupWallpaperInput
  sound: MessageSoundEnum
  type: MessageGroupTypeEnum
  id: ID!
}

input PerformTransactionInput {
  source: TargetTransferInput!
  receiver: TargetTransferInput!
  amount: String!
}

input TargetTransferInput {
  # user id
  user: String

  # pos id
  pos: String

  # wholesaler id
  wholesaler: String

  # manufacturer id
  manufacturer: String
}

input PointOfSaleInput {
  name: String
  title: String
  subtitle: String
  description: String
  tags: [String!]
  brandColor: String
  reference: String
  published: Boolean
  picture: PictureInput
  outsidePictures: [PictureInput!]
  insidePictures: [PictureInput!]
  openingHours: OpeningHoursInput
  specialOffers: [SpecilOfferInput!]
  locations: [FullAddressInput!]
  email: [String!]
  contactEmails: [String!]
  currency: Currency
  languages: [ID!]
  phone: [String!]
  website: String
  chatContact: [SocialValueInput!]
  socialMedia: [SocialValueInput!]
  averageCustomers: Float
  turnover: String
  posCategory: [ID!]
  company: String
  services: [ID!]
  paymentMethods: [ID!]
  loyaltyPrograms: [POSLoyaltyInput!]
}

input OpeningHoursInput {
  status: OpeningStatus!
  hours: [OpeningHoursDayInput!]!
}

input OpeningHoursDayInput {
  day: Days!
  from: String!
  to: String!
}

input SpecilOfferInput {
  offerType: SpecialOffersType
  hours: [OpeningHoursDayInput!]
}

input POSLoyaltyInput {
  loyaltyProgram: String
  from: DateTime!
  to: DateTime!
}

input WholesalerCreateInput {
  name: String
  description: String
  address: FullAddressInput
  picture: PictureInput
  email: String
  company: String
  website: String
  contactEmails: [String!]
  phone: IPhoneInput
  fax: IPhoneInput
}

input WholesalerUpdateInput {
  name: String
  description: String
  address: FullAddressInput
  picture: PictureInput
  email: String
  company: String
  website: String
  contactEmails: [String!]
  phone: IPhoneInput
  fax: IPhoneInput
  id: String!
}

input ManufacturerCreateInput {
  name: String
  picture: PictureInput
  externalId: String
  address: FullAddressInput
  email: String
  company: String
  contactEmails: [String!]
  website: String
}

input ManufacturerUpdateInput {
  name: String
  picture: PictureInput
  externalId: String
  address: FullAddressInput
  email: String
  company: String
  contactEmails: [String!]
  website: String
  id: String!
}

input ModulesDefinitionInput {
  name: String!
  target: TargetTypeEnum
}

input ModulesAssignmentInput {
  module: String!
  assignee: AssigneeInput
}

input SubscribersInput {
  target: TargetACIInput!
  user: String
}

input AccountInput {
  expiresAt: DateTime!
  user: String!
  targets: TargetsInput!
}

enum UserPOSRoleEnum {
  POS_OWNER
  POS_WAITER
  POS_MANAGER
  DELIVERY_MAN
  POS_ASSISTANT
}

input AccountUpdateInput {
  expiresAt: DateTime
  user: String
  targets: TargetsInput
}

input CompanyInput {
  name: String
  description: String
  tags: [String!]
  media: MediaInput
  address: FullAddressInput
  legal: CompanyLegalInput
  banks: [String!]
  contact: CompanyContactDetailsInput
  logistic: Boolean
  externalId: String
  customer: CompanyCustomerInput
  supplier: CompanySupplierInput
  target: TargetACIInput
}

input MediaInput {
  videos: [String!]
  pictures: [PictureInput!]
  deg360: [PictureInput!]
}

input CompanyLegalInput {
  vat: String
  register: String
  licence: String
}

input CompanyContactDetailsInput {
  website: String
  email: String
  phone: PhoneInput
}

input PhoneInput {
  # Phone number
  number: String

  # Phone country code
  countryCode: String
  isValid: Boolean
}

input CompanyCustomerInput {
  phase: CustomerPhaseEnum
  score: String
}

input CompanySupplierInput {
  kind: SupplierTypeEnum
}

input CompanyUpdateInput {
  name: String
  description: String
  tags: [String!]
  media: MediaInput
  address: FullAddressInput
  legal: CompanyLegalInput
  banks: [String!]
  contact: CompanyContactDetailsInput
  logistic: Boolean
  externalId: String
  customer: CompanyCustomerInput
  supplier: CompanySupplierInput
}

input UpdateMediaInput {
  id: ID!
  media: SingleMediaInput!
}

input SingleMediaInput {
  videos: String
  pictures: PictureInput
  deg360: PictureInput
}

input FollowerInput {
  target: TargetACIInput
  user: String
}

input StoriesInput {
  picture: PictureInput
  video: PictureInput
  content: [StoryContentContentInput!]
  user: ID
  pos: ID
  wholesaler: ID
  manufacturer: ID

  # Group id
  group: ID
}

input StoryContentContentInput {
  content: String
  position: StoryContentPositionInput
  dimension: StoryContentDimensionInput
  color: String
  contentType: StoriesContentTypeEnum
}

input StoryContentPositionInput {
  left: Float
  right: Float
  top: Float
  bottom: Float
}

input StoryContentDimensionInput {
  height: Float
  width: Float
  fontSize: Float
}

input BrandInput {
  name: String!
  picture: PictureInput
  externalId: String
  website: String
  manufacturer: String
  target: TargetACIInput
}

input InventoryCategoryInput {
  name: String!
  picture: PictureInput
  layer: Int!
  rank: Int!
  hasChildren: Boolean!
  parent: String
}

input CatalogueCategoryInput {
  portal: Boolean
  pickup: Boolean
  booking: Boolean
  delivery: Boolean
  parent: String
  description: String
  externalId: String
  pictures: [PictureInput!]
  seo: CatalogueCategorySeoInput
  variety: ProductVarietyEnum
  name: String!
  target: TargetACIInput!
  layer: Int!
}

input CatalogueCategorySeoInput {
  urlKey: String
  metaTitle: String
  metaDesription: String
  metaKeywords: [MetaKeywordsInput!]
}

input MetaKeywordsInput {
  name: String
  content: String
}

input CatalogueCategoryBulkInput {
  portal: Boolean
  pickup: Boolean
  booking: Boolean
  delivery: Boolean
  parent: ID
  description: String
  externalId: String!
  pictures: [PictureInput!]
  seo: CatalogueCategorySeoInput
  variety: ProductVarietyEnum
  name: String!
  hasChildren: Boolean!
  target: TargetACIInput!
  rank: Int!
  layer: Int!
}

input CatalogueCategoryUpdateInput {
  portal: Boolean
  pickup: Boolean
  booking: Boolean
  delivery: Boolean
  parent: String
  description: String
  externalId: String
  pictures: [PictureInput!]
  seo: CatalogueCategorySeoInput
  variety: ProductVarietyEnum
  id: ID!
  name: String
  layer: Int
}

input ProductInput {
  externalId: String
  name: String!
  sku: String
  description: String
  descriptionList: [String!]
  specs: [ProductSpecsInput!]
  tags: [String!]
  picture: PictureInput
  pictures: [PictureInput!]
  media: MediaInput
  ean: String
  weight: Float
  price: String!
  class: [ProductClassEnum!]
  wholesalerPrice: String
  factoryPrice: String
  tax: String!
  taxes: [ProductTaxesInput!]
  productAttributes: [String!]

  # list of barcodes ids
  barcodes: [ID!]
  brand: String
  category: [String!]!
}

input ProductSpecsInput {
  key: String
  value: String
}

input ProductTaxesInput {
  tax: ID!
  rank: Int!
}

input ProductUpdateInput {
  externalId: String
  name: String
  sku: String
  description: String
  descriptionList: [String!]
  specs: [ProductSpecsInput!]
  tags: [String!]
  picture: PictureInput
  pictures: [PictureInput!]
  media: MediaInput
  ean: String
  weight: Float
  price: String
  class: [ProductClassEnum!]
  wholesalerPrice: String
  factoryPrice: String
  tax: String
  taxes: [ProductTaxesInput!]
  productAttributes: [String!]

  # list of barcodes ids
  barcodes: [ID!]
  brand: String
  category: [String!]
}

input AttributeCreateInput {
  label: String!
  externalId: String!
  isRequired: Boolean
  isMultipleChoice: Boolean
  pixel: AttributePixelInput
  variety: ProductVarietyEnum
  target: TargetACIInput
}

input AttributePixelInput {
  pixelAttribute: String
}

input AttributeUpdateInput {
  label: String
  isRequired: Boolean
  isMultipleChoice: Boolean
  pixel: AttributePixelInput
  variety: ProductVarietyEnum
  id: ID!
}

input BarcodeUpdateInput {
  product: ID
  internalProduct: ID
  productAttributesValues: [ID!]
  barcode: String
  name: String
  price: String
  priceCredit: [BarcodePeriodCreditInput!]
  discount: DiscountDtoInput
  condition: ProductConditionEnum
  status: ProductStatusEnum
  media: MediaInput
  catalogueCategory: [String!]
  maintenance: InternalProductMaintenanceInput
  pixel: PixelBarcodeInput
  priceList: [ProductPriceListInput!]
  taxes: [ProductTaxesInput!]
  supplier: ID
  id: ID!
}

input BarcodePeriodCreditInput {
  periodCycle: RecurrenceType!
  periodValue: Int!
  amount: String
}

input DiscountDtoInput {
  discountType: DiscountType!
  amount: String
}

input InternalProductMaintenanceInput {
  active: Boolean
  owner: ID
  technician: ID
  prevMaintenanceDuration: Int
  maintenanceDuration: Int
  expectedMeantime: Int
}

input PixelBarcodeInput {
  include: Boolean
}

input ProductPriceListInput {
  price: ID!
  value: String
}

input ProductAttributeInput {
  isRequired: Boolean
  isMultipleChoice: Boolean
  attribute: String!
  reference: String!
  possibleValues: [String!]!
  target: TargetACIInput
}

input ProductAttributeUpdateInput {
  isRequired: Boolean
  isMultipleChoice: Boolean
  id: ID!
  attribute: String
  reference: String
  possibleValues: [String!]
}

input BarcodeInput {
  product: ID
  internalProduct: ID
  productAttributesValues: [ID!]
  barcode: String!
  name: String
  price: String
  priceCredit: [BarcodePeriodCreditInput!]
  discount: DiscountDtoInput
  condition: ProductConditionEnum
  status: ProductStatusEnum
  media: MediaInput
  catalogueCategory: [String!]
  maintenance: InternalProductMaintenanceInput
  pixel: PixelBarcodeInput
  priceList: [ProductPriceListInput!]
  taxes: [ProductTaxesInput!]
  supplier: ID
}

input CreateSimpleProductInput {
  name: String
  description: String
  descriptionList: [String!]
  specs: [ProductSpecsInput!]
  externalId: String
  tags: [String!]
  class: [ProductClassEnum!]
  structure: ProductStructureEnum
  variety: ProductVarietyEnum
  condition: ProductConditionEnum
  status: ProductStatusEnum
  rent: Boolean
  discount: DiscountDtoInput
  sku: String
  seo: CatalogueCategorySeoInput
  brand: String
  picture: PictureInput
  pictures: [PictureInput!]
  media: MediaInput

  # list of suppliers ids
  suppliers: [ID!]
  price: String
  target: TargetACIInput!
  catalogueCategory: [String!]
  globalCategory: GlobalCategoryInput
}

input GlobalCategoryInput {
  googleCategory: ID
  facebookCategory: ID
}

input UpdateSimpleProductInput {
  name: String
  description: String
  descriptionList: [String!]
  specs: [ProductSpecsInput!]
  externalId: String
  tags: [String!]
  class: [ProductClassEnum!]
  structure: ProductStructureEnum
  variety: ProductVarietyEnum
  condition: ProductConditionEnum
  status: ProductStatusEnum
  rent: Boolean
  discount: DiscountDtoInput
  sku: String
  seo: CatalogueCategorySeoInput
  brand: String
  picture: PictureInput
  pictures: [PictureInput!]
  media: MediaInput

  # list of suppliers ids
  suppliers: [ID!]
  price: String
  catalogueCategory: [String!]
  globalCategory: GlobalCategoryInput
  id: ID!
}

input CreateInternalProductInput {
  name: String
  description: String
  descriptionList: [String!]
  specs: [ProductSpecsInput!]
  externalId: String
  tags: [String!]
  class: [ProductClassEnum!]
  structure: ProductStructureEnum
  variety: ProductVarietyEnum
  condition: ProductConditionEnum
  status: ProductStatusEnum
  rent: Boolean
  discount: DiscountDtoInput
  sku: String
  seo: CatalogueCategorySeoInput
  brand: String
  picture: PictureInput
  pictures: [PictureInput!]
  media: MediaInput
  internalProductAttributes: InternalProductAttributeInput

  # list of barcodes ids
  barcodes: [ID!]

  # list of suppliers ids
  suppliers: [ID!]
  price: String
  product: String!
  target: TargetACIInput!
  catalogueCategory: [String!]
  globalCategory: GlobalCategoryInput
}

input InternalProductAttributeInput {
  attributes: [InternalProductAttributeInnerInput!]
}

input InternalProductAttributeInnerInput {
  price: String
  selectedValue: String!
  productAttribute: String!
}

input CreateCustomInternalProductInput {
  name: String
  description: String
  descriptionList: [String!]
  specs: [ProductSpecsInput!]
  externalId: String
  tags: [String!]
  class: [ProductClassEnum!]
  structure: ProductStructureEnum
  variety: ProductVarietyEnum
  condition: ProductConditionEnum
  status: ProductStatusEnum
  rent: Boolean
  discount: DiscountDtoInput
  sku: String
  seo: CatalogueCategorySeoInput
  brand: String
  picture: PictureInput
  pictures: [PictureInput!]
  media: MediaInput
  internalProductAttributes: InternalProductAttributeInput

  # list of barcodes ids
  barcodes: [ID!]

  # list of suppliers ids
  suppliers: [ID!]
  price: String!
  product: String
  target: TargetACIInput!
  productInput: ProductInput
  catalogueCategory: [String!]!
  globalCategory: GlobalCategoryInput
}

input UpdateInternalProductInput {
  name: String
  description: String
  descriptionList: [String!]
  specs: [ProductSpecsInput!]
  externalId: String
  tags: [String!]
  class: [ProductClassEnum!]
  structure: ProductStructureEnum
  variety: ProductVarietyEnum
  condition: ProductConditionEnum
  status: ProductStatusEnum
  rent: Boolean
  discount: DiscountDtoInput
  sku: String
  seo: CatalogueCategorySeoInput
  brand: String
  picture: PictureInput
  pictures: [PictureInput!]
  media: MediaInput
  internalProductAttributes: InternalProductAttributeInput

  # list of barcodes ids
  barcodes: [ID!]

  # list of suppliers ids
  suppliers: [ID!]
  price: String
  product: String
  catalogueCategory: [String!]
  globalCategory: GlobalCategoryInput
  id: ID!
}

input FavoriteLeagueInput {
  user: ID!
  league: Int!
}

input FavoriteTeamInput {
  user: ID!
  team: Int!
}

input CountryInput {
  name: String!
  code: String
  dialCode: String
  flagSquare: PictureInput
  flagWide: PictureInput
  iconFlag: String
}

input StateInput {
  name: String!
  code: String
  created: DateTime!
  surface: String!
  dialCode: String
  flagSquare: PictureInput
  flagWide: PictureInput
  country: ID
}

input LanguageInput {
  name: String!
  code: String
  flagSquare: PictureInput
  flagWide: PictureInput
  iconFlag: String
}

input SocialInput {
  name: String!
  code: String
  fontIcon: String
  images: [SocialImagesInput!]
}

input SocialImagesInput {
  style: SocialImageStyleEnum!
  images: [SocialImagesImagesInput!]
}

input SocialImagesImagesInput {
  svg: SocialImagesImagesSetInput
  png: SocialImagesImagesSetInput
}

input SocialImagesImagesSetInput {
  size48: PictureInput
  size96: PictureInput
  size144: PictureInput
  size240: PictureInput
  size480: PictureInput
}

input PaymentInput {
  name: String!
  code: String
  paymentType: PaymentTypeEnum
  materialIcon: String
  images: PaymentImagesInput
}

input PaymentImagesInput {
  svg: PaymentImagesSvgInput
  png: PaymentImagesPngInput
}

input PaymentImagesSvgInput {
  alt: PictureInput
  card_flat: PictureInput
  dark: PictureInput
  flat: PictureInput
  light: PictureInput
  default: PictureInput
}

input PaymentImagesPngInput {
  alt: PictureInput
  alt2x: PictureInput
  alt_128: PictureInput
  alt_256: PictureInput
  alt_512: PictureInput
  card_flat: PictureInput
  card_flat2x: PictureInput
  card_flat_128: PictureInput
  card_flat_256: PictureInput
  card_flat_512: PictureInput
  dark: PictureInput
  dark2x: PictureInput
  dark_128: PictureInput
  dark_256: PictureInput
  dark_512: PictureInput
  flat: PictureInput
  flat2x: PictureInput
  flat_128: PictureInput
  flat_256: PictureInput
  flat_512: PictureInput
  light: PictureInput
  light2x: PictureInput
  light_128: PictureInput
  light_256: PictureInput
  light_512: PictureInput
  default: PictureInput
  default2x: PictureInput
  default_128: PictureInput
  default_256: PictureInput
  default_512: PictureInput
}

input BrowserInput {
  name: String
  tags: [String!]
  code: String!
  logo: BrowserLogoInput
}

input BrowserLogoInput {
  svg: PictureInput
  png: BrowserLogoPngInput
  icon: String
}

input BrowserLogoPngInput {
  default: PictureInput
  size16: PictureInput
  size24: PictureInput
  size32: PictureInput
  size48: PictureInput
  size64: PictureInput
  size128: PictureInput
  size256: PictureInput
  size512: PictureInput
}

input TechDeviceInput {
  name: String
  tags: [String!]
  code: String
  picture: PictureInput
  releasedat: String
  body: String
  os: String
  storage: String
  displaySize: String
  displayResolution: String
  cameraPixels: String
  videoPixels: String
  ram: String
  chipset: String
  batterySize: String
  batteryType: String
  specifications: TechDeviceSpecsInput
  brand: ID
}

input TechDeviceSpecsInput {
  technology: String
  band2g: String
  gprs: String
  edge: String
  announced: String
  status: String
  dimensions: String
  weight: String
  sim: String
  type: String
  size: String
  resolution: String
  cardSlot: String
  phonebook: String
  callRecords: String
  loudspeaker: String
  alertTypes: String
  jack35mm: String
  wlan: String
  bluetooth: String
  gps: String
  radio: String
  usb: String
  sensors: String
  messaging: String
  browser: String
  clock: String
  alarm: String
  games: String
  languages: String
  java: String
  colors: String
}

input TechDeviceBrandInput {
  name: String!
  code: String
  tags: [String!]
  logo: DeviceBrandLogoInput
}

input DeviceBrandLogoInput {
  svg: PictureInput
  png: DeviceBrandLogoPngInput
  icon: String
}

input DeviceBrandLogoPngInput {
  default: PictureInput
  size16: PictureInput
  size24: PictureInput
  size32: PictureInput
  size48: PictureInput
  size64: PictureInput
  size128: PictureInput
  size256: PictureInput
  size512: PictureInput
}

input TechDeviceTypeInput {
  name: String
  tags: [String!]
  nodeName: String
  code: String
  pictureSquare: PictureInput
  pictureWide: PictureInput
  icon: String
}

input OperatingSystemInput {
  name: String!
  code: String
  tags: [String!]
  slug: String
  logo: OSLogoInput
}

input OSLogoInput {
  svg: PictureInput
  png: OSLogoPngInput
  icon: String
}

input OSLogoPngInput {
  default: PictureInput
  size16: PictureInput
  size24: PictureInput
  size32: PictureInput
  size48: PictureInput
  size64: PictureInput
  size128: PictureInput
}

input EmailTemplateInput {
  name: EmailTemplateTypeEnum!
  content: String!
}

type Subscription {
  listenForUserAuthentication: UserAuthenticationType!
  listenForUserStatusChanged: UserType!
  listenForUserCreated: UserType!
  listenForNewAdhocNotification: NotificationFullType!
  listenForSendAdhocNotificationTest(
    userId: String!
  ): AdhocNotificationTestType!
  listenForNewRequest(userId: ID!): GroupInviteType!
  listenForRequestConfirmed(userId: ID!): GroupInviteType!
  listenForNewMessage(userId: ID!): MessageType!
  listenForMessageGroupUpdated(userId: ID!): MessageGroupType!
  pointOfSaleCreated: PointOfSaleType!
  listenForWholesalerCreated: WholesalerType!
  listenForManufacturerCreated: ManufacturerType!
  listenForSubscriptionRequest(target: TargetACIInput!): SubscribersFullType!
  listenForSubscriptionReply(userId: String!): SubscribersFullType!
  listenForCompanyCreated: CompanyType!
  listenForFollowersCreated(code: String!): FollowerType!
  listenForBrandCreated: BrandType!
  listenForProductCreated: ProductType!
}
